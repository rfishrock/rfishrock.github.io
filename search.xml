<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[C++编程规范]]></title>
    <url>%2F2021%2F04%2F28%2FC%2B%2B%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[1. 命名约定最重要的一致性规则是命名管理. 命名的风格能让我们在不需要去查找类型声明的条件下快速地了解某个名字代表的含义: 类型, 变量, 函数, 常量, 宏, 等等, 甚至, 我们大脑中的模式匹配引擎非常依赖这些命名规则. 命名规则具有一定随意性, 但相比按个人喜好命名, 一致性更重要, 所以无论你认为它们是否重要, 规则总归是规则. 1.1. 通用命名规则总述 函数命名, 变量命名, 文件命名要有描述性; 少用缩写. 说明 尽可能使用描述性的命名, 别心疼空间, 毕竟相比之下让代码易于新读者理解更重要. 不要用只有项目开发者能理解的缩写, 也不要通过砍掉几个字母来缩写单词. 123456789int price_count_reader; // 无缩写int num_errors; // "num" 是一个常见的写法int num_dns_connections; // 人人都知道 "DNS" 是什么int n; // 毫无意义.int nerr; // 含糊不清的缩写.int n_comp_conns; // 含糊不清的缩写.int wgc_connections; // 只有贵团队知道是什么意思.int pc_reader; // "pc" 有太多可能的解释了.int cstmr_id; // 删减了若干字母. 注意, 一些特定的广为人知的缩写是允许的, 例如用 i 表示迭代变量和用 T 表示模板参数. 模板参数的命名应当遵循对应的分类: 类型模板参数应当遵循类型命名的规则, 而非类型模板应当遵循变量命名的规则. 1.2. 文件命名总述 文件名要全部小写, 可以包含下划线 (_) 或连字符 (-), 依照项目的约定. 如果没有约定, 那么 “_” 更好. 说明 可接受的文件命名示例: my_useful_class.cc my-useful-class.cc myusefulclass.cc myusefulclass_test.cc // _unittest 和 _regtest 已弃用. C++ 文件要以 .cpp 结尾, 头文件以 .h 结尾. 专门插入文本的文件则以 .inc 结尾. 不要使用已经存在于 /usr/include 下的文件名 (Yang.Y 注: 即编译器搜索系统头文件的路径), 如 db.h. 通常应尽量让文件名更加明确. http_server_logs.h 就比 logs.h 要好. 定义类时文件名一般成对出现, 如 foo_bar.h 和 foo_bar.cc, 对应于类 FooBar. 内联函数必须放在 .h 文件中. 如果内联函数比较短, 就直接放在 .h 中. 1.3. 类型命名总述 类型名称的每个单词首字母均大写, 不包含下划线: MyExcitingClass, MyExcitingEnum. 说明 所有类型命名 —— 类, 结构体, 类型定义 (typedef), 枚举, 类型模板参数 —— 均使用相同约定, 即以大写字母开始, 每个单词首字母均大写, 不包含下划线. 例如: 12345678910111213// 类和结构体class UrlTable &#123; ...class UrlTableTester &#123; ...struct UrlTableProperties &#123; ...// 类型定义typedef hash_map&lt;UrlTableProperties *, string&gt; PropertiesMap;// using 别名using PropertiesMap = hash_map&lt;UrlTableProperties *, string&gt;;// 枚举enum UrlTableErrors &#123; ... 1.4. 变量命名总述 变量 (包括函数参数) 和数据成员名一律小写, 单词之间用下划线连接. 类的成员变量以下划线结尾, 但结构体的就不用, 如: a_local_variable, a_struct_data_member, a_class_data_member_. 说明 普通变量命名举例: 123string table_name; // 好 - 用下划线.string tableName; // 差 - 混合大小写 类数据成员不管是静态的还是非静态的, 类数据成员都可以和普通变量一样, 但要接下划线. 123456class TableInfo &#123; ... private: string table_name_; // 好 - 后加下划线. static Pool&lt;TableInfo&gt;* pool_; // 好.&#125;; 结构体变量不管是静态的还是非静态的, 结构体数据成员都可以和普通变量一样, 不用像类那样接下划线: 12345struct UrlTableProperties &#123; string name; int num_entries; static Pool&lt;UrlTableProperties&gt;* pool;&#125;; 1.5. 常量命名总述 声明为 constexpr 或 const 的变量, 或在程序运行期间其值始终保持不变的, 命名时以 “k” 开头, 大小写混合. 例如: 1const int kDaysInAWeek = 7; 说明 所有具有静态存储类型的变量 (例如静态变量或全局变量, 参见 存储类型) 都应当以此方式命名. 对于其他存储类型的变量, 如自动变量等, 这条规则是可选的. 如果不采用这条规则, 就按照一般的变量命名规则. 1.6. 函数命名总述 常规函数使用大小写混合, 首字母应小写, 如 myExcitingFunction(), myExcitingMethod(), setMyExcitingMemberVariable(). 说明 一般来说, 函数名的每个单词首字母大写 (即 “驼峰变量名” 或 “帕斯卡变量名”), 没有下划线. 对于首字母缩写的单词, 更倾向于将它们视作一个单词进行首字母大写 (例如, 写作 startRpc() 而非 startRPC()). 123addTableEntry()deleteUrl()openFileOrDie() (同样的命名规则同时适用于类作用域与命名空间作用域的常量, 因为它们是作为 API 的一部分暴露对外的, 因此应当让它们看起来像是一个函数, 因为在这时, 它们实际上是一个对象而非函数的这一事实对外不过是一个无关紧要的实现细节.) 1.7. 命名空间命名总述 命名空间以小写字母命名. 最高级命名空间的名字取决于项目名称. 要注意避免嵌套命名空间的名字之间和常见的顶级命名空间的名字之间发生冲突. 顶级命名空间的名称应当是项目名或者是该命名空间中的代码所属的团队的名字. 命名空间中的代码, 应当存放于和命名空间的名字匹配的文件夹或其子文件夹中. 注意不使用缩写作为名称的规则同样适用于命名空间. 命名空间中的代码极少需要涉及命名空间的名称, 因此没有必要在命名空间中使用缩写. 要避免嵌套的命名空间与常见的顶级命名空间发生名称冲突. 由于名称查找规则的存在, 命名空间之间的冲突完全有可能导致编译失败. 尤其是, 不要创建嵌套的 std 命名空间. 建议使用更独特的项目标识符 (websearch::index, websearch::index_util) 而非常见的极易发生冲突的名称 (比如 websearch::util). 对于 internal 命名空间, 要当心加入到同一 internal 命名空间的代码之间发生冲突 (由于内部维护人员通常来自同一团队, 因此常有可能导致冲突). 在这种情况下, 请使用文件名以使得内部名称独一无二 (例如对于 frobber.h, 使用 websearch::index::frobber_internal). 1.8. 枚举命名总述 枚举的命名应当和 常量 或 宏 一致: kEnumName 或是 ENUM_NAME. 说明 单独的枚举值应该优先采用 常量 的命名方式. 但 宏 方式的命名也可以接受. 枚举名 UrlTableErrors (以及 AlternateUrlTableErrors) 是类型, 所以要用大小写混合的方式. 12345678910enum UrlTableErrors &#123; kOK = 0, kErrorOutOfMemory, kErrorMalformedInput,&#125;;enum AlternateUrlTableErrors &#123; OK = 0, OUT_OF_MEMORY = 1, MALFORMED_INPUT = 2,&#125;; 2009 年 1 月之前, 我们一直建议采用 宏 的方式命名枚举值. 由于枚举值和宏之间的命名冲突, 直接导致了很多问题. 由此, 这里改为优先选择常量风格的命名方式. 新代码应该尽可能优先使用常量风格. 但是老代码没必要切换到常量风格, 除非宏风格确实会产生编译期问题. 1.9. 宏命名总述 你并不打算 使用宏, 对吧? 如果你一定要用, 像这样命名: MY_MACRO_THAT_SCARES_SMALL_CHILDREN. 说明 参考 预处理宏; 通常 不应该 使用宏. 如果不得不用, 其命名像枚举命名一样全部大写, 使用下划线: 12#define ROUND(x) ...#define PI_ROUNDED 3.0 1.10. 命名规则的特例总述 如果你命名的实体与已有 C/C++ 实体相似, 可参考现有命名策略. bigopen(): 函数名, 参照 open() 的形式 1uint`: `typedef bigpos: struct 或 class, 参照 pos 的形式 sparse_hash_map: STL 型实体; 参照 STL 命名约定 1LONGLONG_MAX`: 常量, 如同 `INT_MAX 2. 格式2.1. 函数声明与定义总述 返回类型和函数名在同一行, 参数也尽量放在同一行, 如果放不下就对形参分行, 分行方式与 函数调用 一致. 说明 函数看上去像这样: 1234ReturnType ClassName::functionName(Type par_name1, Type par_name2) &#123; doSomething(); ...&#125; 如果同一行文本太多, 放不下所有参数: 12345ReturnType ClassName::reallyLongFunctionName(Type par_name1, Type par_name2, Type par_name3) &#123; doSomething(); ...&#125; 甚至连第一个参数都放不下: 1234567ReturnType LongClassName::reallyReallyReallyLongFunctionName( Type par_name1, // 4 space indent Type par_name2, Type par_name3) &#123; doSomething(); // 2 space indent ...&#125; 注意以下几点: 使用好的参数名. 只有在参数未被使用或者其用途非常明显时, 才能省略参数名. 如果返回类型和函数名在一行放不下, 分行. 如果返回类型与函数声明或定义分行了, 不要缩进. 左圆括号总是和函数名在同一行. 函数名和左圆括号间永远没有空格. 圆括号与参数间没有空格. 左大括号总在最后一个参数同一行的末尾处, 不另起新行. 右大括号总是单独位于函数最后一行, 或者与左大括号同一行. 右圆括号和左大括号间总是有一个空格. 所有形参应尽可能对齐. 缺省缩进为 2 个空格. 换行后的参数保持 4 个空格的缩进. 未被使用的参数, 或者根据上下文很容易看出其用途的参数, 可以省略参数名: 1234567class Foo &#123; public: Foo(Foo&amp;&amp;); Foo(const Foo&amp;); Foo&amp; operator=(Foo&amp;&amp;); Foo&amp; operator=(const Foo&amp;);&#125;; 未被使用的参数如果其用途不明显的话, 在函数定义处将参数名注释起来: 12345678910111213class Shape &#123; public: virtual void rotate(double radians) = 0;&#125;;class Circle : public Shape &#123; public: void rotate(double radians) override;&#125;;void Circle::rotate(double /*radians*/) &#123;&#125;// 差 - 如果将来有人要实现, 很难猜出变量的作用.void Circle::rotate(double) &#123;&#125; 属性, 和展开为属性的宏, 写在函数声明或定义的最前面, 即返回类型之前: 1MUST_USE_RESULT bool IsOK(); 2.2. 指针和引用表达式总述 句点或箭头前后不要有空格. 指针/地址操作符 (*, &amp;) 之后不能有空格. 说明 下面是指针和引用表达式的正确使用范例: 1234x = *p;p = &amp;x;x = r.y;x = r-&gt;y; 注意: 在访问成员时, 句点或箭头前后没有空格. 指针操作符 * 或 &amp; 后没有空格. 在声明指针变量或参数时, 星号与类型或变量名紧挨都可以: 12345678910// 好, 空格前置.char *c;const string &amp;str;// 好, 空格后置.char* c;const string&amp; str;int x, *y; // 不允许 - 在多重声明中不能使用 &amp; 或 *char * c; // 差 - * 两边都有空格const string &amp; str; // 差 - &amp; 两边都有空格. 在单个文件内要保持风格一致, 所以, 如果是修改现有文件, 要遵照该文件的风格. 在此工程中，我们约定使用引用型参数作为输出或输入输出参数，常引用作为输入参数，例如 1234OperStatus mmp::IterativeClosestPoint::align( const PointCloudRGB &amp;cloud_src, const PointCloudRGB &amp;cloud_tgt,) PointCloudRGB &amp;cloud_result); 2.3. 函数返回值总述 不要在 return 表达式里加上非必须的圆括号. 说明 只有在写 x = expr 要加上括号的时候才在 return expr; 里使用括号. 123456return result; // 返回值很简单, 没有圆括号.// 可以用圆括号把复杂表达式圈起来, 改善可读性.return (some_long_condition &amp;&amp; another_condition);return (value); // 毕竟您从来不会写 var = (value);return(result); // return 可不是函数！ 2.4. 预处理指令总述 预处理指令不要缩进, 从行首开始. 说明 即使预处理指令位于缩进代码块中, 指令也应从行首开始. 1234567891011121314151617// 好 - 指令从行首开始 if (lopsided_score) &#123;#if DISASTER_PENDING // 正确 - 从行首开始 DropEverything();# if NOTIFY // 非必要 - # 后跟空格 NotifyClient();# endif#endif BackToNormal(); &#125;// 差 - 指令缩进 if (lopsided_score) &#123; #if DISASTER_PENDING // 差 - "#if" 应该放在行开头 DropEverything(); #endif // 差 - "#endif" 不要缩进 BackToNormal(); &#125; 2.5. 命名空间格式化总述 命名空间内容不缩进. 说明 命名空间不要增加额外的缩进层次, 例如: 1234567namespace &#123;void foo() &#123; // 正确. 命名空间内没有额外的缩进. ...&#125;&#125; // namespace 不要在命名空间内缩进: 12345678namespace &#123; // 错, 缩进多余了. void foo() &#123; ... &#125;&#125; // namespace 声明嵌套命名空间时, 每个命名空间都独立成行. 12345namespace foo &#123;namespace bar &#123; &#125; // namespace bar&#125; // namespace foo 3. 类3.1. 接口总述 接口是指满足特定条件的类, 这些类以 Interface 为后缀 (不强制). 定义 当一个类满足以下要求时, 称之为纯接口: 只有纯虚函数 (“=0”) 和静态函数 (除了下文提到的析构函数). 没有非静态数据成员. 没有定义任何构造函数. 如果有, 也不能带有参数, 并且必须为 protected. 如果它是一个子类, 也只能从满足上述条件并以 Interface 为后缀的类继承. 接口类不能被直接实例化, 因为它声明了纯虚函数. 为确保接口类的所有实现可被正确销毁, 必须为之声明虚析构函数 (作为上述第 1 条规则的特例, 析构函数不能是纯虚函数). 具体细节可参考 Stroustrup 的 The C++ Programming Language, 3rd edition 第 12.4 节. 优点 以 Interface 为后缀可以提醒其他人不要为该接口类增加函数实现或非静态数据成员. 这一点对于 多重继承 尤其重要. 另外, 对于 Java 程序员来说, 接口的概念已是深入人心. 缺点 Interface 后缀增加了类名长度, 为阅读和理解带来不便. 同时, 接口属性作为实现细节不应暴露给用户. 结论 只有在满足上述条件时, 类才以 Interface 结尾, 但反过来, 满足上述需要的类未必一定以 Interface 结尾. 3.2. 继承总述 使用组合 (YuleFox 注: 这一点也是 GoF 在 &lt;&gt; 里反复强调的) 常常比使用继承更合理. 如果使用继承的话, 定义为 public 继承. 定义 当子类继承基类时, 子类包含了父基类所有数据及操作的定义. C++ 实践中, 继承主要用于两种场合: 实现继承, 子类继承父类的实现代码; 接口继承, 子类仅继承父类的方法名称. 优点 实现继承通过原封不动的复用基类代码减少了代码量. 由于继承是在编译时声明, 程序员和编译器都可以理解相应操作并发现错误. 从编程角度而言, 接口继承是用来强制类输出特定的 API. 在类没有实现 API 中某个必须的方法时, 编译器同样会发现并报告错误. 缺点 对于实现继承, 由于子类的实现代码散布在父类和子类间之间, 要理解其实现变得更加困难. 子类不能重写父类的非虚函数, 当然也就不能修改其实现. 基类也可能定义了一些数据成员, 因此还必须区分基类的实际布局. 结论 所有继承必须是 public 的. 如果你想使用私有继承, 你应该替换成把基类的实例作为成员对象的方式. 不要过度使用实现继承. 组合常常更合适一些. 尽量做到只在 “是一个” (“is-a”, YuleFox 注: 其他 “has-a” 情况下请使用组合) 的情况下使用继承: 如果 Bar 的确 “是一种” Foo, Bar 才能继承 Foo. 必要的话, 析构函数声明为 virtual. 如果你的类有虚函数, 则析构函数也应该为虚函数. 对于可能被子类访问的成员函数, 不要过度使用 protected 关键字. 注意, 数据成员都必须是 私有的. 对于重载的虚函数或虚析构函数, 使用 override, 或 (较不常用的) final 关键字显式地进行标记. 较早 (早于 C++11) 的代码可能会使用 virtual 关键字作为不得已的选项. 因此, 在声明重载时, 请使用 override, final 或 virtual 的其中之一进行标记. 标记为 override 或 final 的析构函数如果不是对基类虚函数的重载的话, 编译会报错, 这有助于捕获常见的错误. 这些标记起到了文档的作用, 因为如果省略这些关键字, 代码阅读者不得不检查所有父类, 以判断该函数是否是虚函数. 4. 头文件4.1. #include 的路径及顺序Tip 使用标准的头文件包含顺序可增强可读性, 避免隐藏依赖: 相关头文件, C 库, C++ 库, 其他库的 .h, 本项目内的 .h. 项目内头文件应按照项目源代码目录树结构排列, 避免使用 UNIX 特殊的快捷目录 . (当前目录) 或 .. (上级目录). 例如, google-awesome-project/src/base/logging.h 应该按如下方式包含: 1#include "base/logging.h" 又如, dir/foo.cc 或 dir/foo_test.cc 的主要作用是实现或测试 dir2/foo2.h 的功能, foo.cc 中包含头文件的次序如下: dir2/foo2.h (优先位置, 详情如下) C 系统文件 C++ 系统文件 其他库的 .h 文件 本项目内 .h 文件 这种优先的顺序排序保证当 dir2/foo2.h 遗漏某些必要的库时， dir/foo.cc 或 dir/foo_test.cc 的构建会立刻中止。因此这一条规则保证维护这些文件的人们首先看到构建中止的消息而不是维护其他包的人们。 dir/foo.cc 和 dir2/foo2.h 通常位于同一目录下 (如 base/basictypes_unittest.cc 和 base/basictypes.h), 但也可以放在不同目录下. 按字母顺序分别对每种类型的头文件进行二次排序是不错的主意。注意较老的代码可不符合这条规则，要在方便的时候改正它们。 您所依赖的符号 (symbols) 被哪些头文件所定义，您就应该包含（include）哪些头文件，前置声明 (forward declarations) 情况除外。比如您要用到 bar.h 中的某个符号, 哪怕您所包含的 foo.h 已经包含了 bar.h, 也照样得包含 bar.h, 除非 foo.h 有明确说明它会自动向您提供 bar.h 中的 symbol. 不过，凡是 cc 文件所对应的「相关头文件」已经包含的，就不用再重复包含进其 cc 文件里面了，就像 foo.cc 只包含 foo.h 就够了，不用再管后者所包含的其它内容。 举例来说, google-awesome-project/src/foo/internal/fooserver.cc 的包含次序如下: 123456789101112&gt; #include "foo/public/fooserver.h" // 优先位置&gt; &gt; #include &lt;sys/types.h&gt;&gt; #include &lt;unistd.h&gt;&gt; &gt; #include &lt;hash_map&gt;&gt; #include &lt;vector&gt;&gt; &gt; #include "base/basictypes.h"&gt; #include "base/commandlineflags.h"&gt; #include "foo/public/bar.h"&gt; 例外： 有时，平台特定（system-specific）代码需要条件编译（conditional includes），这些代码可以放到其它 includes 之后。当然，您的平台特定代码也要够简练且独立，比如： 12345678&gt; #include "foo/public/fooserver.h"&gt; &gt; #include "base/port.h" // For LANG_CXX11.&gt; &gt; #ifdef LANG_CXX11&gt; #include &lt;initializer_list&gt;&gt; #endif // LANG_CXX11&gt; 4.2 #define 保护所有头文件都应该使用 #define 来防止头文件被多重包含, 命名格式当是: &lt;PROJECT&gt;_&lt;PATH&gt;_&lt;FILE&gt;_H . 为保证唯一性, 头文件的命名应该基于所在项目源代码树的全路径. 例如, 项目 foo 中的头文件 foo/src/bar/baz.h 可按如下方式保护: 1234#ifndef FOO_BAR_BAZ_H_#define FOO_BAR_BAZ_H_...#endif // FOO_BAR_BAZ_H_ 在C++ 11标准中，建议使用以下的形式来避免头文件重复包含： 1#pragma once 或 1_Pragma("once") 在本项目中，提倡使用第三种形式的保护. 因为第一种使用ifndef 的保护形式，编译器需要在文件末尾找到 endif 才能确定开发者的意图，对于多次需要 include 的或较长的头文件，这项工作常常需要花费很多时间；而第二种形式本身是宏指令，在后续工作中如果需要使用新的宏指令执行类似的任务时，可能会不得不将宏嵌套在一起从而进入死路.]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NexT阅读量与评论]]></title>
    <url>%2F2020%2F01%2F14%2FLeanCloud%E9%98%85%E8%AF%BB%E9%87%8F%E4%B8%8E%E8%AF%84%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[博客阅读量与评论设置流程。 LeanCloudLeanCloud是针对移动应用的一站式云端服务，为应用开发者提供工具和平台。提供包括LeanStorage 数据存储、LeanMessage 通信服务、LeanAnalytics 统计分析、LeanModules 拓展模块等四大类型的后端云服务。 阅读量LeanCloud配置创建应用，在“存储”分页中，创建“Counter” Class，ACL权限为“无限制”。 在“设置”分页的“应用 Keys”中，获得AppID与AppKey。 在“安全中心”中，添加博客对应的Web安全域名。 Next配置配置NexT主题的_config.yml。以启用LeanCloud阅读量计数并先暂时关闭Hexo针对阅读量的安全插件。 123456leancloud_visitors: enable: true app_id: &lt;your app_id&gt; app_key: &lt;your app_key&gt; security: false betterPerformance: false 配置完成后，将博客重新部署。 修复 LeanCloud 统计插件安全漏洞要求NexT版本在v6.06以上。 云引擎部署“云引擎”处进行“部署”以保证访客数量不被随意篡改，选择“在线编辑”。 创建函数，选择“Hook”类型，并选择“beforeUpdate”，类则选择之前创建的“Counter”类。复制以下代码并保存。 123456789var query = new AV.Query("Counter");if (request.object.updatedKeys.indexOf('time') !== -1) &#123; return query.get(request.object.id).then(function (obj) &#123; if (obj.get("time") &gt; request.object.get("time")) &#123; throw new AV.Cloud.Error('Invalid update!'); &#125; return request.object.save(); &#125;);&#125; 点击“部署”。 NexT配置配置NexT主题的_config.yml。 123456leancloud_visitors: enable: true app_id: &lt;your app_id&gt; app_key: &lt;your app_key&gt; security: true betterPerformance: true 由于 LeanCloud 免费版的云引擎存在请求线程数和运行时间限制以及休眠机制，很多时候访客数量加载会很慢。如果设置“betterPerformance”为 true，则网页则会在提交请求之前直接显示访客人数为查询到的人数+1，以增加用户体验。 安装1npm install hexo-leancloud-counter-security Hexo配置配置Hexo的_config.yml。 123456leancloud_counter_security: enable_sync: true app_id: &lt;&lt;your app id&gt;&gt; app_key: &lt;&lt;your app key&gt; username: password: 键入以下命令。 1hexo lc-counter r &lt;&lt;username&gt;&gt; &lt;&lt;password&gt;&gt; 配置Hexo的_config.yml刚刚设置的用户名和密码（不必与 LeanCloud 的账号相同）。 123456leancloud_counter_security: enable_sync: true app_id: &lt;&lt;your app id&gt;&gt; app_key: &lt;&lt;your app key&gt; username: &lt;&lt;your username&gt;&gt; #如留空则将在部署时询问 password: &lt;&lt;your password&gt;&gt; #如留空则将在部署时询问 在“deploy”添加： 12345deploy:- type: git repository: git@github.com:&lt;&lt;&gt;/&lt;&gt;&gt;.github.io.git branch: master- type: leancloud_counter_security_sync #添加 LeanCloud配置在LeanCloud中检查当前应用的_User类中是否出现一条用户名（上面所设置的）的记录。 设置Counter类权限，将add_fields与create权限设置为指定用户，用户为上面所设置的用户。设置delete权限为指定用户，用户为空。至此权限设置已经完成，数据库记录只能在本地增删。 每次运行 hexo d 部署的时候，插件都会扫描本地 source/_posts 下的文章并与数据库对比，然后在数据库创建没有录入数据库的文章记录。 Error: Cannot find module ‘babel-runtime/regenerator’解决方法：键入以下命令。 1npm install babel-runtime 评论ValineValine 诞生于2017年8月7日，是一款基于LeanCloud的快速、简洁且高效的无后端评论系统。 理论上支持但不限于静态博客，目前已有Hexo、Jekyll、Typecho、Hugo、Ghost等博客程序在使用Valine。 CleanCloud配置创建新的引用，“Comment” Class，ACL为无限制。 在“服务开关”中，只勾选使用“数据存储”。 在“安全域名”中添加域名。 NexT配置在NexT主题的_config.yml中。 1234567891011121314valine: enable: true appid: &lt;&gt; # Your leancloud application appid appkey: &lt;&gt; # Your leancloud application appkey notify: false # Mail notifier. See: https://github.com/xCss/Valine/wiki verify: false # Verification code placeholder: Say something. # Comment box placeholder avatar: mm # Gravatar style guest_info: nick,mail,link # Custom comment header pageSize: 10 # Pagination size language: # Language, available values: en, zh-cn visitor: false comment_count: true #post_meta_order: 0 邮箱提醒有新评论时，会发邮件提醒。 修改NexT主题_config.yml中的valine。 123valine: # Other config notify: true 在LeanCloud中，选择“设置邮件模板”，并修改“用于重置密码的邮件”。 1234567你在&#123;&#123;appname&#125;&#125; 的评论收到了新的回复&lt;p&gt;Hi, &#123;&#123;username&#125;&#125;&lt;/p&gt;&lt;p&gt;你在 &#123;&#123;appname&#125;&#125; 的评论收到了新的回复，请点击查看：&lt;/p&gt;&lt;p&gt;&lt;a href="你的网址首页链接" style="display: inline-block; padding: 10px 20px; border-radius: 4px; background-color: #3090e4; color: #fff; text-decoration: none;"&gt;马上查看&lt;/a&gt;&lt;/p&gt; 修改valine的CDN：next/layout/_third-party/comments/valine.swig，提高加载速度。 12&#123;%- set valine_uri = theme.vendors.valine | default('//cdn.jsdelivr.net/npm/valine/dist/Valine.min.js') %&#125;// 修改前为：'//unpkg.com/valine/dist/Valine.min.js' Reference https://notes.doublemine.me/2015-10-21-%E4%B8%BANexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD.html#%E9%85%8D%E7%BD%AELeanCloud https://www.liaofuzhan.com/posts/554801533.html https://github.com/theme-next/hexo-leancloud-counter-security https://github.com/theme-next/hexo-theme-next/blob/master/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md https://www.jianshu.com/p/728a9594bb6c https://valine.js.org/index.html]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>Hexo</tag>
        <tag>Next</tag>
        <tag>LeanCloud</tag>
        <tag>Valine</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图标]]></title>
    <url>%2F2020%2F01%2F13%2F%E5%9B%BE%E6%A0%87%2F</url>
    <content type="text"><![CDATA[Icons made by Smashicons from www.flaticon.com]]></content>
  </entry>
  <entry>
    <title><![CDATA[CMakeList.txtNote]]></title>
    <url>%2F2019%2F12%2F11%2FCMakeList-txtNote%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566CMAKE_MINIMUM_REQUIRED(VERSION 3.15)## Enable O2 Optimization.SET(CMAKE_CXX_FLAGS "-std=c++14 -O2")## Announce the project name.PROJECT("MMP") ## Multi-Model ProcessingSET(PROJECT_NAME MMP)SET(LIBRARY_NAME MmpShared)## Specify work dirs.SET(PROJECT_BINARY_DIR $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/build)SET(EXECUTABLE_OUTPUT_PATH $&#123;PROJECT_BINARY_DIR&#125;/bin)SET(LIBRARY_OUTPUT_PATH $&#123;PROJECT_BINARY_DIR&#125;/lib)## Find third party dependencies.# PCLFIND_PACKAGE(PCL REQUIRED)INCLUDE_DIRECTORIES($&#123;PCL_INCLUDE_DIRS&#125;)LIST(REMOVE_ITEM PCL_LIBRARIES "vtkproj4") ## needed if install pcl from repo (and libproj-dev)# libLASFIND_PACKAGE(libLAS REQUIRED)INCLUDE_DIRECTORIES($&#123;LIBLAS_INCLUDE_DIRS&#125;)# VTKFIND_PACKAGE(VTK REQUIRED)INCLUDE_DIRECTORIES($&#123;VTK_INCLUDE_DIRS&#125;)# OpenCVFIND_PACKAGE(OpenCV REQUIRED)INCLUDE_DIRECTORIES($&#123;OpenCV_INCLUDE_DIRS&#125;)# Open3D# FIND_PACKAGE(Open3D REQUIRED)# INCLUDE_DIRECTORIES($&#123;Open3D_INCLUDE_DIRS&#125;)SET(THIRD_PARTY_LIBS $&#123;PCL_LIBRARIES&#125; $&#123;libLAS_LIBRARIES&#125; $&#123;VTK_LIBRARIES&#125; $&#123;OpenCV_LIBS&#125; #$&#123;Open3D_LIBRARIES&#125; )IF(NOT WIN32) SET(SPECIAL_OS_LIBS "pthread" "X11") ADD_DEFINITIONS(-Wno-write-strings -fpermissive)ENDIF()set(CMAKE_EXE_LINKER_FLAGS "-fopenmp $&#123;CMAKE_EXE_LINKER_FLAGS&#125;")## Our include directories.INCLUDE_DIRECTORIES($&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/include)## Generate our own shared library.FILE(GLOB_RECURSE SRC_FILES src/*.cpp)LIST(REMOVE_ITEM SRC_FILES $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/main.cpp)FILE(GLOB_RECURSE HEAD_FILES include/*.h)LIST(REMOVE_ITEM HEAD_FILES $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/main.h)FILE(GLOB_RECURSE SAMPLE_FILES sample/*.*)ADD_LIBRARY(MmpShared SHARED $&#123;SRC_FILES&#125; $&#123;SAMPLE_FILES&#125;)TARGET_LINK_LIBRARIES(MmpShared $&#123;THIRD_PARTY_LIBS&#125;)## Specify executable source file.ADD_EXECUTABLE($&#123;PROJECT_NAME&#125; src/main.cpp)## Add all link directories to project.TARGET_LINK_LIBRARIES($&#123;PROJECT_NAME&#125; MmpShared) 1234567891011121314151617181920cmake_minimum_required(VERSION 3.15)project(PCL_DETECT)set(CMAKE_CXX_STANDARD 14)add_executable(PCL_Detect main.cpp)find_package(libLAS REQUIRED)find_package(VTK REQUIRED)include_directories(/usr/local/include/liblas)include_directories(/usr/local/include/pcl-1.8)include_directories(/usr/local/include/eigen3)include_directories(/usr/local/include/vtk-5.10)target_link_libraries(PCL_Detect /usr/local/lib/liblas.so)target_link_libraries(PCL_Detect /usr/lib/x86_64-linux-gnu/libboost_thread.so.1.58.0)target_link_libraries(PCL_Detect /usr/lib/x86_64-linux-gnu/libboost_system.so.1.58.0)target_link_libraries(PCL_Detect /usr/lib/libpcl_visualization.so)target_link_libraries(PCL_Detect /usr/lib/libpcl_io.so.1.8)]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>CMake</tag>
        <tag>Linux</tag>
        <tag>Clion</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkdownNote]]></title>
    <url>%2F2019%2F11%2F30%2FMarkdownNote%2F</url>
    <content type="text"><![CDATA[下标、上标123x&lt;sub&gt;i&lt;/sub&gt;H&lt;sub&gt;2&lt;/sub&gt;O CO&lt;sub&gt;2&lt;/sub&gt;益达&lt;sup&gt;TM&lt;/sup&gt; xiH2O CO2益达TM 表格简单 12345name | 价格 | 数量 -|-|-香蕉 | $1 | 5 |苹果 | $1 | 6 |草莓 | $1 | 7 | name 价格 数量 香蕉 $1 5 苹果 $1 6 草莓 $1 7 标准 12345Name | 价格 | 数量 | - | :-: | -:香蕉 | $1 | 5 |苹果 | $1 | 6 |草莓 | $1 | 7 | Name 价格 数量 香蕉 $1 5 苹果 $1 6 草莓 $1 7 Referencehttps://blog.csdn.net/qq_40147863/article/details/82014166 https://www.jianshu.com/p/b0f56b7d7ee8]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>Markdown</tag>
        <tag>Language</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法Note]]></title>
    <url>%2F2019%2F11%2F30%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95Note%2F</url>
    <content type="text"><![CDATA[排序方法 时间复杂度（平均） 时间复杂度（最好） 时间复杂度（最坏） 空间复杂度 稳定度 直接插入 O(n2) O(n) O(n2) O(1) √ 希尔排序 O(n1.3) O(n) O(n2) O(1) × 选择排序 O(n2) O(n2) O(n2) O(1) × 堆排序 O(nlog2n) O(nlog2n) O(nlog2n) O(1) × 冒泡排序 O(n2) O(n) O(n2) O(1) √ 快速排序 O(nlog2n) O(nlog2n) O(n2) O(nlog2n) × 归并排序 O(nlog2n) O(nlog2n) O(nlog2n) O(n) √ 计数排序 O(n+k) O(n+k) O(n+k) O(n+k) √ 桶排序 O(n+k) O(n) O(n2) O(n+k) √ 基数排序 O(d(r+n))O(n*k) O(d(n+rd))O(n*k) O(d(r+n))O(n*k) O(rd+n)O(n+k) √ 基数排序中，r表示关键字的基数，d表示长度，n表示关键字个数。 不稳定算法：快些选堆（快排，希尔，直接选择，堆）。 假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的。 插入排序（Insertion Sort）插入排序是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 步骤 从有序数列和无序数列{a2,a3，…，an}开始进行排序； 处理第i个元素时（i=2,3，…，n），数列{a1,a2，…，ai-1}是已有序的，而数列{ai,ai+1，…，an}是无序的。用ai与ai-1，a i-2，…，a1进行比较，找出合适的位置将ai插入； 重复第二步，共进行n-i次插入处理，数列全部有序。 C++1234567891011121314void insertion_sort(int arr[], int len)&#123; for (int i = 1; i &lt; len; i++) &#123; int current = arr[i]; int preIndex = i - 1; while ((preIndex &gt;= 0) &amp;&amp; (current &lt; arr[preIndex])) &#123; arr[preIndex + 1] = arr[preIndex]; preIndex--; &#125; arr[preIndex + 1] = current; &#125;&#125; Javascript1234567891011121314function insertionSort(arr) &#123; var len = arr.length; var preIndex, current; for (var i = 1; i &lt; len; i++) &#123; preIndex = i - 1; current = arr[i]; while (preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) &#123; arr[preIndex + 1] = arr[preIndex]; preIndex--; &#125; arr[preIndex + 1] = current; &#125; return arr;&#125; 希尔排序（Shell’s Sort）希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。 希尔排序是基于插入排序的以下两点性质而提出改进方法的：插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位。 希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。 步骤 先取一个正整数d1&lt;n，把所有序号相隔d1的数组元素放一组，组内进行直接插入排序； 然后取d2&lt;d1，重复上述分组和排序操作； 直至di=1，即所有记录放进一个组中排序为止。 选择排序（Selection Sort）选择排序是一种简单直观的排序算法。 它的工作原理是：第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零。选择排序是不稳定的排序方法。 步骤 初始状态：无序区为R[1..n]，有序区为空。 第1趟排序在无序区R[1..n]中选出关键字最小的记录R[k]，将它与无序区的第1个记录R[1]交换，使R[1..1]和R[2..n]分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区。 第i趟排序第i趟排序开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区。 堆排序（Heap Sort）堆排序是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法： 大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列； 小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列； 步骤 将待排序序列构建成一个堆 H[0……n-1]，根据（升序降序需求）选择大顶堆或小顶堆； 把堆首（最大值）和堆尾互换； 把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置； 重复步骤 2，直到堆的尺寸为 1。 冒泡排序（Bubble Sort）冒泡排序是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 步骤 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 快速排序（Quick Sort）快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。 步骤 从数列中挑出一个元素，称为 “基准”（pivot）; 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作； 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序； 归并排序（Merge Sort）归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。 步骤 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列； 设定两个指针，最初位置分别为两个已经排序序列的起始位置； 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置； 重复步骤 3 直到某一指针达到序列尾； 将另一序列剩下的所有元素直接复制到合并序列尾。 计数排序（Counting Sort）计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。 步骤 找出待排序的数组中最大和最小的元素； 统计数组中每个值为i的元素出现的次数，存入数组C的第i项； 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）； 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。 桶排序（Bucket Sort）桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点： 在额外空间充足的情况下，尽量增大桶的数量 使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中 同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。 步骤 确定桶的个数与桶的取值范围； 遍历待排序序列，将元素放入对应的桶中； 分别对每个桶中的元素进行排序； 将桶中的元素按顺序放到原始数组中，完成排序。 基数排序（Radix Sort）基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。 步骤最高位优先（Most Significant Digit first，MSD） 按k1排序分组，同一组中记录，关键码k1相等； 对各组按k2排序分成子组； 对后面的关键码继续这样的排序分组，直到按最次位关键码kd对各子组排序后。再将各组连接起来，便得到一个有序序列。 最低位优先（Least Significant Digit first, LSD) 从kd开始排序; 对kd-1进行排序，依次重复，直到对k1排序后便得到一个有序序列。 基数排序 vs 计数排序 vs 桶排序基数排序有两种方法： 这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异： 基数排序：根据键值的每位数字来分配桶； 计数排序：每个桶只存储单一键值； 桶排序：每个桶存储一定范围的数值； Referencehttps://www.cnblogs.com/onepixel/articles/7674659.html https://www.jianshu.com/p/40dcc3b83ddc https://sort.hust.cc/ https://www.runoob.com/w3cnote_genre/algorithm]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无法生成cv2.soSolution]]></title>
    <url>%2F2019%2F11%2F25%2F%E6%97%A0%E6%B3%95%E7%94%9F%E6%88%90cv2-soSolution%2F</url>
    <content type="text"><![CDATA[OpenCV编译完成后无法生成cv2.so原因分析。 Bug背景OpenCV编译OpenCV是一个基于BSD许可（开源）发行的跨平台计算机视觉库，轻量级而且高效实现了图像处理和计算机视觉方面的很多通用算法。在当前的版本中，OpenCV将函数模块分为主库与contrib库管理。因此，虽然python语言的opencv接口可以通过pip实现简易版安装，但是如果需要使用到完整OpenCV库的功能（包括Caffe深度学习框架编译的应用等），则需要采用传统的源码编译的方式。 OpenCV本身因版本交替，就较为容易出现与安装说明不相符，参数调整，模块数据调整，与操作系统不兼容等各种问题，而这些问题都有可能引发最后编译bug的生成。 场景背景此次bug场景出现在了最近一次对另一个bug场景复现过程当中。原先需复现的场景（也就是一开始想要用来做软件测试课程报告的场景）主要是在Caffe深度学习框架的编译过程中对matlab接口，即matcaffe的编译报错。而在Caffe框架编译中，则首先需要完成OpenCV的编译。然而，在OpenCV编译完成后，则出现了编译无法生成cv2.so的bug。 该bug在之前的项目经历当中都从未出现且在网上没有一个明确的对该bug的解释以及解决方案，最终花费了较长的时间才得到解决，因此特做此记录。 该bug场景可在相同环境中复现。 实际bug场景实际环境 本次bug场景的相关实际系统环境如下： 操作系统：Ubuntu16.04 LTS CUDA9.0 CUDNN7.5 Anaconda2 (Python2.7) 相关硬件如下： 显卡：NVIDIA MX150 2G 安装所需相关依赖如下： build-essential cmake git pkg-config libjpeg8-dev libtiff5-dev libjasper-dev libpng12-dev libgtk2.0-dev libavcodec-dev libavformat-dev libswscale-dev libv4l-dev libatlas-base-dev gfortran 安装python相关库如下： numpy imutils Opencv版本： 3.4.0 3.4.6 实际流程OpenCV在获得OpenCV包以及OpenCV-contrib包之后，编译流程如下： 12345678910mkdir build &amp;&amp; cd buildcmake -D CMAKE_BUILD_TYPE=RELEASE \​ -D CMAKE_INSTALL_PREFIX=/usr/local \​ -D INSTALL_C_EXAMPLES=OFF \​ -D INSTALL_PYTHON_EXAMPLES=ON \​ -D OPENCV_EXTRA_MODULES_PATH=~/opencv_contrib/modules \​ -D BUILD_EXAMPLES=ON ..sudo make -j8sudo make installsudo ldconfig 上述流程都能够顺利完成。 实际bug描述当在Anacond虚拟环境下使用python需要调用Opencv接口时，需要将在安装路径下的cv2.so链接到虚拟环境下的python路径当中： 12cd ~/anaconda2/envs/caffe/lib/python2.7/site-pakages/ln -s /usr/local/lib/python2.7/site-pakages/cv2.so cv2.so 通过如下语句进行OpenCV编译是否成功进行测试： 1import cv2 则出现报错： 1ImportError: No module named cv2 报错显示，在python当中并不能正确的引入OpenCV库。 第一时间考虑链接的问题，通过ls -l命令后可以发现当前链接是个坏链，因此查看安装路径发现编译过程并没有生成cv2.so。 该bug定位以及修复的难点在于： 整个编译过程（见2.2）没有出现interrupt，没有报error，无法通过error对bug进行定位。 OpenCV本身编译中的许多not found warning最终只是对个别模块的支持受限，对OpenCV正常使用不造成影响，因此对通过log排查bug造成难度。 此次bug在网上并没有一致的案例，属于较为特殊的情况。 Bug成因成因分析要清楚bug的成因，首先要知道cv2.so是什么。 cv2.so是支持python调用OpenCV的动态链接库，即在python程序运行时能够被动态的申请并调用，因此cv2.so的缺失，与OpenCV源码在对支持python的接口部分编译出现了问题，或者是OpenCV编译时并没有编译python接口模块。 前面在2.2与2.3中提到，在该bug场景当中，整个编译流程并没有interrupt，因此编译报错的情况首先应可以排除，那么cv2.so无法生成的原因就可以限定于是OpenCV没有编译python接口模块。 那么，为什么OpenCV没有编译python接口呢？ 2.3中提到，OpenCV在一些not found warning中，会对模块的编译产生受限，那么python接口的未编译就极有可能是因为OpenCV在cmake阶段查询python环境时，未查询到python的某部分环境，在编译阶段无法链接所需python库，最终导致了python接口的未编译。 最终在cmake的log文件当中： 1-- Could NOT find PythonLibs (missing: PYTHON_INCLUDE_DIRS) 验证了当前猜想。 因此，我们可以归结出OpenCV编译无法生成cv2.so在该场景下的成因，即是当前环境下python库的缺失。 补充3.1中已对bug成因进行了分析，在这里补充一下为什么在已有python环境的情况下，依然会有类库依赖缺失问题。 Linux发行版通常会把类库的头文件和相关的pkg-config分拆成一个单独的xxx-dev(el)包。针对python环境下，该类库即python-dev。 那么什么情况需要安装python-dev？ 需要自己安装一个源外的python类库, 而这个类库内含需要编译的调用python API的c/c++文件（如：安装使用WiringpisPi库需要python-dev）。 你自己写的一个程序编译需要链接libpythonXX.(a/so)(注:以上不含使用ctypes/ffi或者裸dlsym方式直接调用libpython.so) 其他正常使用python或者通过安装源内的python类库的不需要python-dev. 发现并修复bug过程4中归纳1-3中发现并修复bug的过程： 查看cv2.so链接状态，并发现cv2.so缺失。 进行重编译，确认流程步骤完整，并尝试bug复现。 查看cmake过程的log文件，未发现实际相关error。查看lib文件夹下libopencv类库链接正常。 确认是否为cmake参数问题，核对参数，并对相关参数条件覆盖测试(各取OFF/ON)。依然无法修复bug，排除cmake参数问题。 尝试使用OpenCV3.4.6（原3.4.0）进行编译，仍然无法修复bug，排除版本更替丢失或兼容性问题。 查询到一个案例（见参考资料），该案例因在python中没有安装numpy库依赖，导致最终cv2.so无法生成。该案例提供了本bug场景的一个解决思路，即cv2.so的生成失败可能与python环境缺失相关。 查看log文件，发现python类库在编译过程中并未找到，支持了步骤6中的猜想。 “sudo apt-get install python2.7-dev”安装python类依赖。 重新编译，成功生成cv2.so，并可通过“import”测试。 参考资料百度百科(opencv): https://baike.baidu.com/item/opencv/10320623?fr=aladdin pyimagesearch(Install OpenCV 3.0 and Python 2.7+ on Ubuntu): https://www.pyimagesearch.com/2015/06/22/install-opencv-3-0-and-python-2-7-on-ubuntu/ cnblogs(没有cv2.so文件): https://www.cnblogs.com/whu-zeng/p/6284795.html cnblogs(python和python-dev): https://www.cnblogs.com/cj2014/p/3848673.html csdn(Linux下动态库和静态库的制作及使用): https://blog.csdn.net/AXW2013/article/details/86495942]]></content>
      <categories>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>Environment</tag>
        <tag>OpenCV</tag>
        <tag>CV</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PCLNote]]></title>
    <url>%2F2019%2F11%2F14%2FPCLNote%2F</url>
    <content type="text"><![CDATA[PCL（Point Cloud Library， 点云库）是一个大型跨平台开源C++编程库，实现了大量点云相关的通用算法和高效数据结构。 PCL是BSD授权方式，可以免费进行商业和学术的应用。 包含模块 分割 (Segmentation) 特征描述与提取 (Features) 可视化 (Visualization) 曲面重建 (Surface) 识别 (Recognition) 检索 (Search) 配准 (Registration) 关键点 (Keypoints) 滤波 (Filters) 采样一致性 (Sample consensus) 八叉树 (octree) 通用模块 (common) 输入输出 (IO) k维树 (kdtree) 适用平台 普通多核或单核计算机（x86…） 嵌入式专用系统（ARM …） RGBD及其他点云获取设备 GPU kdtree, octree三维测量设备获取的点云数据，具有数据量大、分布不均匀等特点。作为三维领域里面另一个重要的数据来源，点云数据主要是表征目标表面的海量点集合，并不具备传统实体网格数据的几何拓扑信息。点云数据处理中最为核心的问题就是建立离散点间的拓扑关系，实现基于领域关系的快速查找。 建立空间索引在点云数据处理中被广泛应用，而这些结构中，k-d tree和八叉树在3D点云数据组织中的应用较为广泛。PCL对八叉树的数据结构建立和索引方法进行了实现，以方便在此基础上的其他点云处理操作。 Filters在获取点云数据时，由于环境等因素带来的影响，以及电磁波衍射特性、被测物体表面性质变化和数据拼接配准操作过程的影响，点云数据将不可避免地出现一些噪声点。 实际应用中，除了测量随机误差产生的噪声点之外，由于受到外界干扰如视线遮挡、障碍物等因素的影响，点云数据中往往存在着一些离主体点云（即被测物体点云）较远的离散点，即离群点，不同的获取设备点云噪声结构也有不同，其它可以通过滤波重采样完成的工作，有空洞修复、信息损失最小海量点云数据压缩处理等。 在点云处理流程中，滤波处理作为预处理的第一步，往往对后续处理管道影响很大，只有在滤波预处理中将噪声点、离群点、孔洞、数据压缩等按照后续处理定制，才能够更好地进行配准等后续应用处理。 PCL中点云滤波模块提供了很多灵活实用的滤波处理算法，例如双边滤波、高斯滤波、条件滤波、直通滤波、基于随机采样一致性滤波等，关键的滤波模块是作为PCL的一个处理成员模块，其在应用中与其它点云处理流程集成。 Keypoints关键点也称为兴趣点，它是2D图像、3D点云或曲面模型上，可以通过定义检测标注来获取的具有稳定性、区别性的点集。 从技术上来说，关键点的数量相比与原始点云或图像的数据量小很多，它与局部特征描述子结合在一起，组成关键点描述子，常用来形成原始数据的紧凑表示，而且不失代表性与描述性，从而可以加快后续识别、追踪等对数据的处理速度。关键点提取是2D与3D信息处理中不可或缺的关键技术。 Sample consensus在CV领域广泛应用各种不同的采样一致性参数估计算法，用于排除错误的样本，样本不同，对应的应用则不同，例如剔除错误的配准点对，分割出处在模型上的点集等。 PCL中以随机采样一致性算法（RANSAC）为核心，同时实现了五种类似于随机采样一致性估计（RANSAC）、最大似然一致性估计（MLESAC）、最大中值方差一致性估计（LMEDS）等，所有的估计参数算法都符合一致性准则。 Features3D点云特征描述与提取是点云信息处理中最基础也是最关键的一部分，点云的识别、分割、重采样、配准、曲面重建等处理的大部分算法，都严重依赖特征描述与提取的结果。 从尺度上来分，一般分为局部特征描述和全局特征描述，例如局部的法线等几何形状特征的描述，全局的拓扑特征描述，都属于3D点云特征描述与提取范畴。 在PCL中，目前已有很多基本的特征描述子与提取算法。 Registration在逆向工程、CV、文物数字化等领域中，由于点云的不完整、旋转错位、平移错位等，使得要得到完整点云就需对局部点云就需对点云进行配准。 为了得到被测物体的完整数据模型，需要确定一个合适的坐标变换，将从各个视角得到的点集合并到一个统一的坐标系下，形成一个完整的数据点云，然后就可以方便地进行可视化等操作，这就是点云数据的配准。 点云自动配准有手动配准、依赖仪器的配准和自动配准。通常我们所说的点云配准技术即是指自动配准。 点云自动配准技术是通过一定的算法或者统计学规律，利用计算机计算两块点云之间的错位，从而达到把两片点云配准的效果。其实质是把在不同的坐标系中测量得到的数据点云进行坐标变换，以得到整体的数据模型。问题的关键是如何求得坐标变换参数R（旋转矩阵）和T（变换向量），使得两视角下测得的三维数据经坐标转换后的距离最小。 目前，配准算法按照实现过程可以分为整体配准和局部配准。 PCL中有单独的配准模块，实现了相关的基础数据结构与经典配准算法如ICP等，以及配准过程中的对应点估计、错误对应点去除等流程。配准的关键技术设计关键点选取、与特征描述与提取两部分。 Surface曲面重建技术在逆向工程、数据可视化、机器视觉、虚拟现实、医疗技术等领域中得到了广泛的应用。 根据重建曲面和数据点云之间的关系可将曲面重建分为两大类：插值法和逼近法。前者得到的重建曲面完全通过原始数据点，而后者则是用分片线性曲面或其它形式的曲面来逼近原始数据点，从而使得产生的重建曲面是原始点集的一个逼近。而根据重建曲面的表现形式不同又可以将它分为以下五种：参数曲面重建、隐式曲面重建、变形曲面重建、细分曲面重建和分片线性曲面重建。 PCL中目前实现了基于点云的曲面重建模块框架，在此基础上进一步实现了比较基础的泊松重建、MC重建、Ear Clipping等算法。 Reference《点云库PCL从入门到精通》]]></content>
      <categories>
        <category>LIDAR</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LIDAR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[libLAS编译安装]]></title>
    <url>%2F2019%2F11%2F07%2FLibLAS%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[libLAS是一个C/C++库，用于读取和写入常见的LAS LIDAR格式。 编译GeoTIFF12345wget https://download.osgeo.org/geotiff/libgeotiff/libgeotiff-1.3.0.tar.gztar -xvf libgeotiff-1.3.0.tar.gz &amp;&amp; cd libgeotiff-1.3.0./configuremakesudo make install 编译libLAS1234mkdir makefiles &amp;&amp; cd makefilessudo cmake -G "Unix Makefiles" ..sudo makesudo make install 验证1lasinfo &lt;file_path&gt; PDAL截至2018年，libLAS已经被PDAL项目取代，进入休眠和维护状态。libLAS不提供PDAL提供的对LAS或LAZ 1.4的支持。 并且PDAL提供Python的支持。 lasinfo: error while loading shared libraries: liblas.so.3: cannot open shared object file: No such file or directorylasinfo: error while loading shared libraries: liblas.so.3: cannot open shared object file: No such file or directory 解决方法： 1LD_LIBRARY_PATH="/usr/local/lib" lasinfo]]></content>
      <categories>
        <category>LIDAR</category>
      </categories>
      <tags>
        <tag>LIDAR</tag>
        <tag>Environment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[本地hexo博客迁移]]></title>
    <url>%2F2019%2F11%2F07%2F%E6%9C%AC%E5%9C%B0hexo%E5%BA%93%E8%BF%81%E7%A7%BB%2F</url>
    <content type="text"><![CDATA[Hexo博客本地库迁移至另一台主机参考流程。 Hexo搭建可参考：https://rfishrock.github.io/2016/10/03/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/ 复制原本地文件将下面的文件或文件夹复制到新的博客目录下进行替换： 123_config.ymlsource/themes/ Hexo各文件说明.deploy：执行hexo deploy命令部署到GitHub上的内容目录 public：执行hexo generate命令，输出的静态网页内容目录 scaffolds：layout模板文件目录，其中的md文件可以添加编辑 scripts：扩展脚本目录，这里可以自定义一些javascript脚本 source：文章源码目录，该目录下的markdown和html文件均会被hexo处理。该页面对应repo的根目录，404文件、favicon.ico文件，CNAME文件等都应该放这里，该目录下可新建页面目录。 _drafts：草稿文章 _posts：发布文章 themes：主题文件目录 _config.yml：全局配置文件，大多数的设置都在这里 package.json：应用程序数据，指明hexo的版本等信息，类似于一般软件中的关于按钮 Referencehttps://www.jianshu.com/p/a713bd430e0f]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LivoxNote]]></title>
    <url>%2F2019%2F11%2F05%2FLivoxNote%2F</url>
    <content type="text"><![CDATA[产品概述 坐标系]]></content>
      <categories>
        <category>LIDAR</category>
      </categories>
      <tags>
        <tag>LIDAR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开源许可证Note]]></title>
    <url>%2F2019%2F11%2F05%2F%E5%BC%80%E6%BA%90%E8%AE%B8%E5%8F%AF%E8%AF%81Note%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>OpenSource</category>
      </categories>
      <tags>
        <tag>OpenSource</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TensorFlow各版本对应]]></title>
    <url>%2F2019%2F10%2F30%2FTensorFlow%E5%90%84%E7%89%88%E6%9C%AC%E5%AF%B9%E5%BA%94%2F</url>
    <content type="text"><![CDATA[TensorFlow对应各环境下的版本，即不同版本下所需环境。 Windowshttps://tensorflow.google.cn/install/source_windows CPU GPU Linuxhttps://tensorflow.google.cn/install/source CPU GPU macOSCPU GPU]]></content>
      <categories>
        <category>DeepLearning</category>
      </categories>
      <tags>
        <tag>TensorFlow</tag>
        <tag>DeepLearning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法复杂度Note]]></title>
    <url>%2F2019%2F10%2F30%2F%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[在大O符号表示法中，时间复杂度的公式是： T(n) = O( f(n) )，其中f(n) 表示每行代码执行次数之和，而 O 表示正比例关系，这个公式的全称是：算法的渐进时间复杂度。 常见的时间复杂度量级从上至下依次的时间复杂度越来越大，执行的效率越来越低。 常数阶O(1) 对数阶O(logN) 线性阶O(n) 线性对数阶O(nlogN) 平方阶O(n^2) 立方阶O(n^3) K次方阶O(n^k) 指数阶(2^n) 常数阶O(1)无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)，如： 12345int i = 1;int j = 2;++i;j++;int m = i + j; 上述代码在执行的时候，它消耗的时候并不随着某个变量的增长而增长，那么无论这类代码有多长，即使有几万几十万行，都可以用O(1)来表示它的时间复杂度。 对数阶O(logN)12345int i = 1;while(i &lt; n)&#123; i = i * 2;&#125; 从上面代码可以看到，在while循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了。我们试着求解一下，假设循环x次之后，i 就大于 n 了，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 x = log2n。 也就是说当循环log2n次以后，这个代码就结束了。因此这个代码的时间复杂度为：O(logn)。 线性阶O(n)12345for(i=1; i&lt;=n; ++i)&#123; j = i; j++;&#125; 这段代码，for循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的，因此这类代码都可以用O(n)来表示它的时间复杂度。 线性对数阶O(nlogN)线性对数阶O(nlogN) 其实非常容易理解，将时间复杂度为O(logn)的代码循环N遍的话，那么它的时间复杂度就是 n * O(logN)，也就是了O(nlogN)。 12345678for(m=1; m&lt;n; m++)&#123; i = 1; while(i &lt; n) &#123; i = i * 2; &#125;&#125; 平方阶O(n^2)如果把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²) 了。 12345678for(x=1; i&lt;=n; x++)&#123; for(i=1; i&lt;=n; i++) &#123; j = i; j++; &#125;&#125; 这段代码其实就是嵌套了2层n循环，它的时间复杂度就是 O(n*n)，即 O(n²)如果将其中一层循环的n改成m，即： 12345678for(x=1; i&lt;=m; x++)&#123; for(i=1; i&lt;=n; i++) &#123; j = i; j++; &#125;&#125; 那它的时间复杂度就变成了 O(m*n) 立方阶O(n^3)、K次方阶O(n^k)参考上面的O(n^2) 去理解就好了，O(n^3)相当于三层n循环，其它的类似。 Referencehttps://blog.csdn.net/jsjwk/article/details/84315770]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python在字符串前补零]]></title>
    <url>%2F2019%2F10%2F11%2FPython%E5%9C%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%89%8D%E8%A1%A5%E9%9B%B6%2F</url>
    <content type="text"><![CDATA[用于对不规则字符串（如命名）进行转换。 zfill() &amp; rjust()Python zfill() 方法返回指定长度的字符串，原字符串右对齐，前面填充0。 1str.zfill(width) Python rjust() 返回一个原字符串右对齐,并使用空格填充至长度 width 的新字符串。如果指定的长度小于字符串的长度则返回原字符串。 width – 指定填充指定字符后中字符串的总长度. fillchar – 填充的字符，默认为空格。 1str.rjust(width[, fillchar]) 示例： 1234img_name = "1011"print(img_name.zfill(6))print(img_name.rjust(6, '0')) 输出： 12001011001011 补充补充特殊情况。 1234img_name = "1011"print(img_name.zfill(1))print(img_name.rjust(1, '0')) 输出： 1210111011 rjust()可使用单个字符对字符串进行补足。另外有rjust()， Python也提供有ljust()。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu中NVIDIA驱动安装]]></title>
    <url>%2F2019%2F10%2F08%2FUbuntu%E4%B8%ADNVIDIA%E9%A9%B1%E5%8A%A8%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Ubuntu系统中本身不带有英伟达显卡驱动，然而如果需要安装CUDA、CUDNN则必须有驱动支持。 获取显卡支持驱动的版本https://www.nvidia.com/Download/index.aspx 提供该显卡目前版本驱动 https://www.geforce.cn/drivers 提供该显卡支持的所有驱动 通过以上两个网址可以获得显卡支持的驱动版本信息以及驱动下载。相对来说比较推荐采用第二个网址取获得多个版本的驱动，因为新版驱动相对支持的CUDA以及模型较少。 关于是否需要禁用Nouveau这里先提前讨论一下关于网上教程一般会提到的禁用Nouveau问题。Nouveau是第三方的开源NVIDIA驱动。然而目前也有教程上提过一些方法安装驱动不需要禁用Nouveau与图形界面。之前的配置经验中确实也有过在不禁用情况下，成功安装了驱动。因此，是否禁用Nouveau，是否会因此造成什么样的问题，目前还不好定论。 安装驱动这里介绍三种安装Nvidia驱动的方法，可以根据自己的需要进行安装。 使用标准Ubuntu库安装驱动 检测显卡型号以及推荐的驱动： 1ubuntu-drivers devices 从此命令中可以获得显卡所支持的驱动版本，包括系统推荐的驱动版本。 如果选择安装推荐的驱动版本，则也直接使用命令： 1sudo ubuntu-drivers autoinstall 如果想自己选择安装的版本，则可以使用： 1sudo apt install nvidia-version 重启系统。 使用PPA库安装驱动PPA为Personal Package Archives的缩写，即个人软件包档案。 Personal Package Archives（个人软件包档案）是Ubuntu Launchpad网站提供的一项服务，允许个人用户上传软件源代码，通过Launchpad进行编译并发布为2进制软件包，作为apt/新立得源供其他用户下载和更新。在Launchpad网站上的每一个用户和团队都可以拥有一个或多个PPA。 使用PPA库可安装不稳定版本的Beta驱动。 添加PPA库至系统中： 12sudo add-apt-repository ppa:graphics-drivers/ppasudo apt update 后续步骤可参考3.1中步骤1-3。 手动安装NVIDIA官方网站中驱动 识别NVIDIA VGA卡： 1lshw -numeric -C display 或者： 1lspci -vnn | grep VGA 从官方网站中下载驱动。 禁用默认的Nouveau驱动。 将Nouveau驱动加入黑名单。 12sudo bash -c "echo blacklist nouveau &gt; /etc/modprobe.d/blacklist-nvidia-nouveau.conf"sudo bash -c "echo options nouveau modeset=0 &gt;&gt; /etc/modprobe.d/blacklist-nvidia-nouveau.conf" 验证新modprobe config文件内容： 1cat /etc/modprobe.d/blacklist-nvidia-nouveau.conf 应显示： 12blacklist nouveauoptions nouveau modeset=0 更新Kernel initramfs： 1sudo update-initramfs -u 重启系统： 1sudo reboot 验证Nouveau是否已经禁用： 1lsmod | grep nouveau 无显示则已经禁用。 此步骤之前确保系统已经重启并禁用Nouveau。暂停图形界面： 1sudo telinit 3 按CTRL+ALT+F1进入TTY1会话，并使用用户名与密码登录。 启用驱动安装： 1bash NVIDIA-Linux-x86_64-version.bin 重启系统。 验证驱动是否安装安装完成后，可通过NVIDIA X Server Settings验证驱动版本。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu中sublime text安装]]></title>
    <url>%2F2019%2F10%2F07%2FUbuntu%E4%B8%ADsublime-text%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[用于日常代码编写，以及文本查看。 安装（Stable）12345wget -qO - https://download.sublimetext.com/sublimehq-pub.gpg | sudo apt-key add -sudo apt-get install apt-transport-httpsecho "deb https://download.sublimetext.com/ apt/stable/" | sudo tee /etc/apt/sources.list.d/sublime-text.listsudo apt-get updatesudo apt-get install sublime-text 显示编辑器中空格显示空格在于方便检查python等语法的严格缩进。同样适用于Windows下。 菜单中选择Preferences，Settings。在settings-User中添加 1"draw_white_space": "all"]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu中typora安装]]></title>
    <url>%2F2019%2F10%2F07%2FUbuntu%E4%B8%ADtypora%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Markdown编辑器与阅读器。 安装1234wget -qO - https://typora.io/linux/public-key.asc | sudo apt-key add -sudo add-apt-repository 'deb https://typora.io/linux ./'sudo apt-get updatesudo apt-get install typora MarkdownMarkdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。 当前许多网站都广泛使用 Markdown 来撰写帮助文档或是用于论坛上发表消息。例如：GitHub、简书、reddit、Diaspora、Stack Exchange、OpenStreetMap 、SourceForge等。 菜鸟教程 https://www.runoob.com/markdown/md-tutorial.html]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu中apt源与pip源替换]]></title>
    <url>%2F2019%2F10%2F03%2FUbuntu%E4%B8%ADapt%E6%BA%90%E4%B8%8Epip%E6%BA%90%E6%9B%BF%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[Advanced Packaging Tool (apt) 是Linux下的安装包管理工具。Pip 是 Python 包管理工具,该工具提供了对Python 包的查找、下载、安装、卸载的功能。更换源的必要性在于提高各种包的下载速度。 Apt源更换为阿里镜像源进入ubuntu“软件与更新”。ubuntu软件分页中，“下载自”选项选择使用http://mirros.aliyun.com/ubuntu 阿里云镜像源。 Pip源更换为清华源修改 ~/.pip/pip.conf (没有可自行创建)，修改index-url至tuna，内容如下： 12[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple Conda源更换为清华源输入如下两行命令： 12conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --set show_channel_urls yes]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Pip</tag>
        <tag>Conda</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu系统安装]]></title>
    <url>%2F2019%2F10%2F02%2FUbuntu%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Ubuntu16.04 LTS安装记录。 通过国内镜像获得系统镜像文件访问网易开源镜像站 http://mirrors.163.com/ 获得 ubuntu-16.04.6-desktop-amd64.iso 文件。 刻录引导盘使用Rufus https://rufus.ie/en_IE.html 将ISO文件刻入至所选择U盘。刻入过程将使U盘格式化。 进入主机Bios并设置U盘启动项开机时进入Bios界面，不同型号主板Bios不同。 华硕TUF主板 开机按Del或F2进入Bios。 进入Advanced Mode。 选择Boot并进入Secure Boot。 将OS Type修改为Windows UEFI mode。 进入Key Management， 选择Clear Secure Boot Keys关闭Secure Boot。 返回初始Bios界面，通过Boot Menu选择U盘路径进行启动。 安装系统语言推荐初始选择英语，防止出现英文路径不匹配情况。 安装过程推荐选择不联网安装，减少因为网络问题安装时间的延长。 系统安装分为双系统安装与单系统安装。 先了解系统安装中系统分区中，各分区思路。 [分区：主分区] [格式：Ext4] [挂载点：/] [空间起始位置] 系统分区。 [分区：逻辑分区] [格式：] [挂载点：swap] [空间起始位置] 当使用所有RAM容量时，操作系统需要释放一些RAM，并且需要一个位置来将被选择的被释放的信息保留在RAM中，这就是所谓的交换空间。 交换空间通常是硬盘中的特殊分区，与计算机的RAM容量成正比。对于少于8GB的RAM：使用2或3倍的RAM量。对于超过8gb且小于64gb：使用1到1.5倍的RAM量。超过64gb：4gb的互换或完全没有交换。 [分区：逻辑分区] [格式：Ext4] [挂载点：/boot] [空间起始位置] 用于系统引导。 [分区：逻辑分区] [格式：Ext4] [挂载点：/home] [空间起始位置] 存储分区。 Windows与Ubuntu双系统策略双系统安装，推荐在安装好Windows系统后，再启动Ubuntu安装程序。在安装引导程序中，直接选择保留Windows安装Ubuntu选项（不考虑前面所提分区策略，使用安装程序默认分配方案）。因为两个系统所采用的文件格式不相同，在Windows系统下，无法查看到Ubuntu系统分区以及文件。而Ubuntu系统则可以与Windows共用挂载盘。因此在之后如果出现需要在Windows系统下再次调整分区时，要特别注意该特性。 之后安装程序将引导对Windows与Ubuntu两个系统的磁盘空间进行分配。注意如果安装过程中没有出现磁盘空间分配过程，应为分区出现问题。需中断当前安装，检查当前的分区情况。此过程中分配与Ubuntu的空间，为Ubuntu系统主分区。之后Ubuntu可使用Windows挂载分区作为逻辑分区。 Ubuntu单系统策略推荐自定义分区，在Ubuntu系统需要重装时，重新分配系统分区是非常有帮助的。 目前个人的分区方案： [分区：主分区] [格式：Ext4] [挂载点：/] [空间起始位置] [分配空间：0.65*(500g-32gb-200mb)] [分区：逻辑分区] [格式：] [挂载点：swap] [空间起始位置] [分配空间：32gb] [分区：逻辑分区] [格式：Ext4] [挂载点：/boot] [空间起始位置] [分配空间：200mb] [分区：逻辑分区] [格式：Ext4] [挂载点：/home] [空间起始位置] [分配空间：0.35*(500g-32gb-200mb)]]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo引入本地相对路径图片]]></title>
    <url>%2F2019%2F10%2F02%2FHexo%E5%BC%95%E5%85%A5%E6%9C%AC%E5%9C%B0%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[在Blog中将原先使用外链引入的图片改为本地引入图片。 相对路径引用将Hexo站点配置文件_config.yml中post_asset_folder属性改为true。 这时假使我们创建新post， 1hexo new post_name 我们将在_post文件夹下获得post_name.md文件以及post_name文件夹。post_name文件夹用于存储引入的图片。同时在post_name.md中引入图片： 1&#123;% asset_img img_name img_alt %&#125; 为什么不使用![]方法Hexo本身使用![]方法插入图片是没有问题的， 1![img_alt](img_name) 在post下也可正常显示。然而在next主题中，如加入read more功能时，主页中图片的路径会因为使用相对路径而无法正常显示。因此此时选择使用hexo3新方法：{}。]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[仿淘宝登录网页编写]]></title>
    <url>%2F2016%2F10%2F16%2F%E7%99%BB%E5%BD%95%E7%BD%91%E9%A1%B5%E7%BC%96%E5%86%99%2F</url>
    <content type="text"><![CDATA[HTML+CSS+javascript Set Up WebStorm DetailWebStorm一款JavaScript 开发工具。被广大中国JS开发者誉为“Web前端开发神器”、“最强大的HTML5编辑器”、“最智能的JavaScript IDE”等。与IntelliJ IDEA同源，继承了IntelliJ IDEA强大的JS部分的功能。 HTML一种超文本标记语言，标准通用标记语言下的一个应用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;link href="bootstrap-3.3.5-dist/css/bootstrap.min.css " rel="stylesheet"&gt; &lt;link href="styles.css" rel="stylesheet"&gt; &lt;link href="js.js" rel="stylesheet"&gt; &lt;script language="JavaScript" src="js.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="top"&gt; &lt;img src="logo.png"&gt;&lt;/div&gt;&lt;div class="mid"&gt; &lt;div class="midin"&gt; &lt;form class="login"&gt; &lt;div class="title"&gt;&lt;b style="display: block;" id="login_txt"&gt;用户登录&lt;/b&gt; &lt;div class="alert alert-danger" id="alert_warn" &gt; &lt;img src="error.png" alt="warn"&gt; &lt;b id="warn_txt"&gt;&lt;/b&gt; &lt;/div&gt; &lt;div class="alert alert-success" id="alert_success"&gt; &lt;b&gt;&amp;nbsp;登录成功&lt;/b&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="input-group"&gt; &lt;span class="input-group-addon" &gt; &lt;span class="glyphicon glyphicon-user"&gt; &lt;/span&gt; &lt;/span&gt; &lt;input type="text" class="form-control" value=" 账号（手机号）" id="username" onFocus="if(value==defaultValue)&#123;value='';this.style.color='#000'&#125;" onBlur="if(!value)&#123;value=defaultValue;this.style.color='#c2a599';&#125;" style="color:#999999; font-family: 'Microsoft YaHei UI'; width: 260px" maxlength="11" onkeyup="this.value=this.value.replace(/\D/g,'')" onafterpaste="this.value=this.value.replace(/\D/g,'')"&gt; &lt;/div&gt; &lt;div class="input-group"&gt; &lt;span class="input-group-addon"&gt; &lt;span class="glyphicon glyphicon-lock"&gt; &lt;/span&gt; &lt;/span&gt; &lt;input type="text" class="form-control" value=" 密码" name="input_psw" oninput="pswInputting()" id="password" onFocus="if(value==defaultValue)&#123;value='';this.style.color='#000'&#125;" onBlur="if(!value)&#123;value=defaultValue;this.style.color='#c2a599';&#125;" style="color:#999999; font-family: 'Microsoft YaHei UI'; width: 260px" maxlength="32"&gt; &lt;/div&gt; &lt;button class="btn" type="button" onclick="setTimeout($tip(), 200);" id="btn_submit"&gt;登 录&lt;/button&gt; &lt;a href="#" id="forget"&gt;忘记密码&lt;/a&gt; &lt;a href="#" id="reg"&gt;免费注册&lt;/a&gt; &lt;/form&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class="bottom"&gt; &lt;hr&gt; &lt;div class="b1"&gt; &lt;a href="#"&gt;阿里巴巴集团&lt;/a&gt; | &lt;a href="#"&gt;阿里巴巴国际站&lt;/a&gt; | &lt;a href="#"&gt;阿里巴巴中国站&lt;/a&gt; | &lt;a href="#"&gt;全球速卖通&lt;/a&gt; | &lt;a href="#"&gt;淘宝网&lt;/a&gt; | &lt;a href="#"&gt;天猫&lt;/a&gt; | &lt;a href="#"&gt;聚划算&lt;/a&gt; | &lt;a href="#"&gt;一陶&lt;/a&gt; | &lt;a href="#"&gt;阿里妈妈&lt;/a&gt; | &lt;a href="#"&gt;淘宝旅行&lt;/a&gt; | &lt;a href="#"&gt;虾米&lt;/a&gt; | &lt;a href="#"&gt;阿里云计算&lt;/a&gt; | &lt;a href="#"&gt;云OS&lt;/a&gt; | &lt;a href="#"&gt;万网&lt;/a&gt; | &lt;a href="#"&gt;支付宝&lt;/a&gt; | &lt;a href="#"&gt;来往&lt;/a&gt; | &lt;hr&gt; &lt;/div&gt; &lt;div class="b2"&gt; &lt;div class="b21"&gt; &lt;a href="#"&gt;关于淘宝&lt;/a&gt; &lt;a href="#"&gt;合作伙伴&lt;/a&gt; &lt;a href="#"&gt;营销中心&lt;/a&gt; &lt;a href="#"&gt;廉政举报&lt;/a&gt; &lt;a href="#"&gt;联系客服&lt;/a&gt; &lt;a href="#"&gt;开放平台&lt;/a&gt; &lt;a href="#"&gt;诚征英才&lt;/a&gt; &lt;a href="#"&gt;联系我们&lt;/a&gt; &lt;a href="#"&gt;网站地图&lt;/a&gt; &lt;a href="#"&gt;法律声明&lt;/a&gt; @2016 Taobao.com 版权所有 &lt;/div&gt; 网络文化经营许可证； 网文网[2010]040号 | &lt;span id="zengzhi"&gt;增值电信业务经营许可证：浙B2-20080224-1 | 信息网络传播许可证：1109364&lt;/span&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; CSS一种用来表现HTML（标准通用标记语言的一个应用）或XML（标准通用标记语言的一个子集）等文件样式的计算机语言。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111.body&#123; margin: 0; padding: 0;&#125;.top&#123; width: 1200px; height: 80px; margin:0 auto 0 auto; padding:15px 0 15px 0;&#125;.mid&#123; height: 600px; background: url("login-bg.jpg") no-repeat center;&#125;.blank&#123; height: 70px;&#125;.bottom&#123; width: 1200px; margin: 0 auto 0 auto;&#125;.b1&#123; height: 44px;&#125;.b1 a&#123; color: #666;&#125;.b2&#123; height: 60px;&#125;.b21&#123; height: 30px;&#125;.b21 a&#123; color:#555555&#125;#zengzhi&#123; color: #333;&#125;.login&#123; float: right; width: 350px; height: 350px; background-color: #f1f6ff; margin-top: 100px; border-radius: 5px;&#125;.midin&#123; width: 1200px; margin: 0 auto 0 auto;&#125;.title&#123; margin: 35px 20px 35px 20px;&#125;.input-group&#123; margin: 0 20px 30px 20px; height: 40px;&#125;.input-group input&#123; height: 40px;&#125;.btn&#123; width: 310px; background-color: #f84e4e; margin:0 20px 30px 20px; font-family:"黑体"; color:white;&#125;.btn:hover&#123; background-color: #f89999; color:white;&#125;#forget&#123; float: left; margin-left: 20px; color:#555555;&#125;#reg&#123; float: right; margin-right: 20px; color:#555555;&#125;#alert_warn&#123; display: none; hegiht: 27px; margin-right: 11px; padding: 0px;&#125;#alert_warn img&#123; width: 22px; hegiht: 22px; color:white;&#125;#alert_warn b&#123; color: #ff2624; font-size: smaller; font-weight: 700; font-size: 15px;&#125;#alert_success&#123; display: none; height: 27px; margin-right: 11px; padding: 0px;&#125;#alert_success b&#123; color: #1d8031; font-size: smaller; font-weight: 700; font-size: 15px;&#125; javascript一种直译式脚本语言，是一种动态类型、弱类型、基于原型的语言，内置支持类型。它的解释器被称为JavaScript引擎，为浏览器的一部分，广泛用于客户端的脚本语言，最早是在HTML（标准通用标记语言下的一个应用）网页上使用，用来给HTML网页增加动态功能。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980function pswInputting() &#123; var psw_input = document.getElementsByName("input_psw").item(0); var str = psw_input.value; if (str.length != 0) &#123; if (str == " 密码") &#123; return; &#125; psw_input.type = "password"; &#125; else &#123; psw_input.type = "text"; &#125;&#125;function $tip()&#123; var username = document.getElementById("username"); var password = document.getElementsByName("input_psw").item(0); var reg = /^0?1[3|4|5|8][0-9]\d&#123;8&#125;$/; var login_txt = document.getElementById("login_txt"); var warn_txt = document.getElementById("warn_txt"); var block = document.getElementById("alert_warn"); var block_success = document.getElementById("alert_success"); var btn = document.getElementById("btn_submit"); btn.style.color = "#ffffff"; btn.blur(); var flag; setTimeout("", 200); if (username.value == " 账号（手机号）" || username.value == "") &#123; warn_txt.innerHTML = "&lt;strong&gt;账户不能为空！&lt;/strong&gt;"; flag = 1; &#125; else if (!reg.test(username.value)) &#123; warn_txt.innerHTML = "&lt;strong&gt;账户为11位有效手机号！&lt;/strong&gt;"; flag = 2; &#125;else if (password.value == " 密码" || password.value == "") &#123; warn_txt.innerHTML = "&lt;strong&gt;密码不能为空！&lt;/strong&gt;"; flag = 4; &#125; else if (username.value != "13012345678") &#123; warn_txt.innerHTML = "&lt;strong&gt;用户尚未注册！&lt;/strong&gt;"; flag = 3; &#125; else if (password.value != "123456") &#123; warn_txt.innerHTML = "&lt;strong&gt;密码错误！&lt;/strong&gt;"; flag = 5; &#125; else &#123; block.style.display = "none"; block_success.style.display = "block"; login_txt.style.display = "none"; flag = 6; &#125; setTimeout("reset()", 3000); switch (flag) &#123; case 1: case 2: case 3: block_success.style.display = "none"; login_txt.style.display = "none"; block.style.display = "block"; var elem = document.getElementById("username"); elem.focus(); break; case 4: case 5: block_success.style.display = "none"; login_txt.style.display = "none"; block.style.display = "block"; var elem = document.getElementById("password"); elem.focus(); break; case 6: break; &#125;&#125;function reset() &#123; var login_txt = document.getElementById("login_txt"); var block = document.getElementById("alert_warn"); var block_success = document.getElementById("alert_success"); login_txt.style.display = "block"; block.style.display = "none"; block_success.style.display = "none";&#125; Problems and SolutionsCSS盒子模型网页设计中常听的属性名：内容(content)、填充(padding)、边框(border)、边界(margin)， CSS盒子模式都具备这些属性。这些属性我们可以用日常生活中的常见事物——盒子作一个比喻来理解，所以叫它盒子模式。CSS盒子模型就是在网页设计中经常用到的CSS技术所使用的一种思维模型。 内容（CONTENT）就是盒子里装的东西；而填充(PADDING)就是怕盒子里装的东西（贵重的）损坏而添加的泡沫或者其它抗震的辅料；边框(BORDER)就是盒子本身了；至于边界(MARGIN)则说明盒子摆放的时候的不能全部堆在一起，要留一定空隙保持通风，同时也为了方便取出。在网页设计上，内容常指文字、图片等元素，但是也可以是小盒子（DIV嵌套），与现实生活中盒子不同的是，现实生活中的东西一般不能大于盒子，否则盒子会被撑坏的，而CSS盒子具有弹性，里面的东西大过盒子本身最多把它撑大，但它不会损坏的。填充只有宽度属性，可以理解为生活中盒子每个HTML标记都可看作一个盒子；]]></content>
      <categories>
        <category>Front-end</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>CSS</tag>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[静态博客搭建]]></title>
    <url>%2F2016%2F10%2F03%2F%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[Github+Git+Hexo+NexT+Markdown Set Up Node.js Git DetailGithub一个面向开源及私有软件项目的托管平台,只支持Git。在Github上注册用户，并新建repository(username.github.io)。 Git一款免费、开源的分布式版本控制系统。在站点目录（本地blog文件夹)右键Git Bash here。 123$ git init //初始一个Git仓库$ git config --global user.name 'yourname' //首次需设置账户$ git config --global user.email 'youremail' //首次设置账户邮箱 配置SSH Keys。 12$ ssh-keygen -t rsa -C youremail@example.com //生成SSH Key$ cd~/.ssh //检查本机的ssh密钥 将公钥文件中内容复制到Github账号的SSH Key中。 1$ ssh git@github.com //检查是否连接 后面操作大部分在Git上执行。 Hexo一个简单、快速、强大的博客发布工具，支持Markdown格式。 123$ npm install -g hexo //安装Hexo$ hexo init //在本地初始搭建一个Hexo博客$ hexo server //在本地(localhost:4000)查看博客 修改站点(blog文件夹）配置文件(_config.yml)。 1234deploy: type: git repository: git@github.com:username/username.github.io.git branch: master 继续Hexo部署。 1234$ npm install hexo-deployer-git --save //安装hexo-deployer-git$ hexo clean //清除缓存$ hexo g //生成静态网页$ hexo d //部署到远程Github 静态博客基本搭成。 NexT精于心，简于形。一个好看的Hexo博客主题，iissnan/hexo-theme-next 12$ cd your-hexo-site //进入你的站点目录$ git clone https//github.com/iissnan/hexo-theme-next themes/next//从Git上克隆主题（适用所有从从Git上克隆库的方法） 修改站点配置文件。 1theme: next 关于NexT主题配置等可以查看NexT使用文档。 Markdown一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。Hexo新建文章：在your-hexo-site/source/_posts目录下新建.md文件。 Problems and Solutions安装Hexo问题注意Node.js与Hexo版本是否相符。 win10系统版本问题因win10版本以及Hexo版本问题，在执行命令与站点配置文件修改上面都有些许不同，应根据自己的情况加以调整（此篇blog皆为本机的处理情况）。 404问题最需要注意的是自己账号（username）是否与repository的username.github.io相符。 远程博客与本地查看不相符，出现乱码问题根据分析此问题应该出在Github远程网页更新上，如果本地查看博客网页没有出现错误，就需要等待时间刷新网页之后恢复正常。 Markdown语法问题要注意所有的标记符号后一定要空格。 Addition克隆远程仓库和提交申请 1$ git clone git@github.com:username/hellogit.git 1234$ git add yourfile$ git commit -m "yourcommit"$ git remote add origin git@github.com:username/hellogit.git$ git push -u origin master]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>Hexo</tag>
        <tag>Git</tag>
      </tags>
  </entry>
</search>
