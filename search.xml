<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CMakeList.txtNote]]></title>
    <url>%2F2019%2F12%2F11%2FCMakeList-txtNote%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920cmake_minimum_required(VERSION 3.15)project(PCL_DETECT)set(CMAKE_CXX_STANDARD 14)add_executable(PCL_Detect main.cpp)find_package(libLAS REQUIRED)find_package(VTK REQUIRED)include_directories(/usr/local/include/liblas)include_directories(/usr/local/include/pcl-1.8)include_directories(/usr/local/include/eigen3)include_directories(/usr/local/include/vtk-5.10)target_link_libraries(PCL_Detect /usr/local/lib/liblas.so)target_link_libraries(PCL_Detect /usr/lib/x86_64-linux-gnu/libboost_thread.so.1.58.0)target_link_libraries(PCL_Detect /usr/lib/x86_64-linux-gnu/libboost_system.so.1.58.0)target_link_libraries(PCL_Detect /usr/lib/libpcl_visualization.so)target_link_libraries(PCL_Detect /usr/lib/libpcl_io.so.1.8)]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>CMake</tag>
        <tag>Linux</tag>
        <tag>Clion</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法Note]]></title>
    <url>%2F2019%2F11%2F30%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95Note%2F</url>
    <content type="text"><![CDATA[类别 排序方法 时间复杂度（平均） 时间复杂度（最好） 时间复杂度（最坏） 空间复杂度 稳定度 插入排序 直接插入 O(n2) O(n) O(n2) O(1) √ 希尔排序 O(n1.3) O(n) O(n2) O(1) × 选择排序 直接排序 O(n2) O(n2) O(n2) O(1) × 堆排序 O(nlog2n) O(nlog2n) O(nlog2n) O(1) × 交换排序 冒泡排序 O(n2) O(n) O(n2) O(1) √ 快速排序 O(nlog2n) O(nlog2n) O(n2) O(nlog2n) × 归并排序 O(nlog2n) O(nlog2n) O(nlog2n) O(n) √ 基数排序 O(d(r+n))O(n*k) O(d(n+rd))O(n*k) O(d(r+n))O(n*k) O(rd+n)O(n+k) √ 基数排序中，r表示关键字的基数，d表示长度，n表示关键字个数。 不稳定算法：快些选堆（快排，希尔，直接选择，堆）。 假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的。 插入排序（Insertion Sort）插入排序是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 步骤 从有序数列和无序数列{a2,a3，…，an}开始进行排序； 处理第i个元素时（i=2,3，…，n），数列{a1,a2，…，ai-1}是已有序的，而数列{ai,ai+1，…，an}是无序的。用ai与ai-1，a i-2，…，a1进行比较，找出合适的位置将ai插入； 重复第二步，共进行n-i次插入处理，数列全部有序。 希尔排序（Shell’s Sort）希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。 希尔排序是基于插入排序的以下两点性质而提出改进方法的：插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位。 希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。 步骤 先取一个正整数d1&lt;n，把所有序号相隔d1的数组元素放一组，组内进行直接插入排序； 然后取d2&lt;d1，重复上述分组和排序操作； 直至di=1，即所有记录放进一个组中排序为止。 选择排序（Selection Sort）选择排序是一种简单直观的排序算法。 它的工作原理是：第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零。选择排序是不稳定的排序方法。 步骤 初始状态：无序区为R[1..n]，有序区为空。 第1趟排序在无序区R[1..n]中选出关键字最小的记录R[k]，将它与无序区的第1个记录R[1]交换，使R[1..1]和R[2..n]分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区。 第i趟排序第i趟排序开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区。 堆排序（Heap Sort）堆排序是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法： 大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列； 小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列； 步骤 将待排序序列构建成一个堆 H[0……n-1]，根据（升序降序需求）选择大顶堆或小顶堆； 把堆首（最大值）和堆尾互换； 把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置； 重复步骤 2，直到堆的尺寸为 1。 冒泡排序（Bubble Sort）冒泡排序是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 步骤 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 Referencehttps://www.cnblogs.com/onepixel/articles/7674659.html https://www.jianshu.com/p/40dcc3b83ddc https://sort.hust.cc/]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkdownNote]]></title>
    <url>%2F2019%2F11%2F30%2FMarkdownNote%2F</url>
    <content type="text"><![CDATA[上标、下标123x&lt;sub&gt;i&lt;/sub&gt;H&lt;sub&gt;2&lt;/sub&gt;O CO&lt;sub&gt;2&lt;/sub&gt;益达&lt;sup&gt;TM&lt;/sup&gt; xiH2O CO2益达TM 表格简单 12345name | 价格 | 数量 -|-|-香蕉 | $1 | 5 |苹果 | $1 | 6 |草莓 | $1 | 7 | name 价格 数量 香蕉 $1 5 苹果 $1 6 草莓 $1 7 标准 12345Name | 价格 | 数量 | - | :-: | -:香蕉 | $1 | 5 |苹果 | $1 | 6 |草莓 | $1 | 7 | Name 价格 数量 香蕉 $1 5 苹果 $1 6 草莓 $1 7 Referencehttps://blog.csdn.net/qq_40147863/article/details/82014166 https://www.jianshu.com/p/b0f56b7d7ee8]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>Markdown</tag>
        <tag>Language</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无法生成cv2.soSolution]]></title>
    <url>%2F2019%2F11%2F25%2F%E6%97%A0%E6%B3%95%E7%94%9F%E6%88%90cv2-soSolution%2F</url>
    <content type="text"><![CDATA[OpenCV编译完成后无法生成cv2.so原因分析。 Bug背景OpenCV编译​ OpenCV是一个基于BSD许可（开源）发行的跨平台计算机视觉库，轻量级而且高效实现了图像处理和计算机视觉方面的很多通用算法。在当前的版本中，OpenCV将函数模块分为主库与contrib库管理。因此，虽然python语言的opencv接口可以通过pip实现简易版安装，但是如果需要使用到完整OpenCV库的功能（包括Caffe深度学习框架编译的应用等），则需要采用传统的源码编译的方式。 ​ OpenCV本身因版本交替，就较为容易出现与安装说明不相符，参数调整，模块数据调整，与操作系统不兼容等各种问题，而这些问题都有可能引发最后编译bug的生成。 场景背景​ 此次bug场景出现在了最近一次对另一个bug场景复现过程当中。原先需复现的场景（也就是一开始想要用来做软件测试课程报告的场景）主要是在Caffe深度学习框架的编译过程中对matlab接口，即matcaffe的编译报错。而在Caffe框架编译中，则首先需要完成OpenCV的编译。然而，在OpenCV编译完成后，则出现了编译无法生成cv2.so的bug。 ​ 该bug在之前的项目经历当中都从未出现且在网上没有一个明确的对该bug的解释以及解决方案，最终花费了较长的时间才得到解决，因此特做此记录。 ​ 该bug场景可在相同环境中复现。 实际bug场景实际环境 本次bug场景的相关实际系统环境如下： 操作系统：Ubuntu16.04 LTS CUDA9.0 CUDNN7.5 Anaconda2 (Python2.7) 相关硬件如下： 显卡：NVIDIA MX150 2G 安装所需相关依赖如下： build-essential cmake git pkg-config libjpeg8-dev libtiff5-dev libjasper-dev libpng12-dev libgtk2.0-dev libavcodec-dev libavformat-dev libswscale-dev libv4l-dev libatlas-base-dev gfortran 安装python相关库如下： numpy imutils Opencv版本： 3.4.0 3.4.6 实际流程OpenCV在获得OpenCV包以及OpenCV-contrib包之后，编译流程如下： 12345678910mkdir build &amp;&amp; cd buildcmake -D CMAKE_BUILD_TYPE=RELEASE \​ -D CMAKE_INSTALL_PREFIX=/usr/local \​ -D INSTALL_C_EXAMPLES=OFF \​ -D INSTALL_PYTHON_EXAMPLES=ON \​ -D OPENCV_EXTRA_MODULES_PATH=~/opencv_contrib/modules \​ -D BUILD_EXAMPLES=ON ..sudo make -j8sudo make installsudo ldconfig 上述流程都能够顺利完成。 实际bug描述​ 当在Anacond虚拟环境下使用python需要调用Opencv接口时，需要将在安装路径下的cv2.so链接到虚拟环境下的python路径当中： 12cd ~/anaconda2/envs/caffe/lib/python2.7/site-pakages/ln -s /usr/local/lib/python2.7/site-pakages/cv2.so cv2.so 通过如下语句进行OpenCV编译是否成功进行测试： 1import cv2 则出现报错： 1ImportError: No module named cv2 报错显示，在python当中并不能正确的引入OpenCV库。 ​ 第一时间考虑链接的问题，通过ls -l命令后可以发现当前链接是个坏链，因此查看安装路径发现编译过程并没有生成cv2.so。 ​ 该bug定位以及修复的难点在于： ​ 1. 整个编译过程（见2.2）没有出现interrupt，没有报error，无法通过error对bug进行定位。 ​ 2. OpenCV本身编译中的许多not found warning最终只是对个别模块的支持受限，对OpenCV正常使用不造成影响，因此对通过log排查bug造成难度。 ​ 3. 此次bug在网上并没有一致的案例，属于较为特殊的情况。 Bug成因成因分析​ 要清楚bug的成因，首先要知道cv2.so是什么。 ​ cv2.so是支持python调用OpenCV的动态链接库，即在python程序运行时能够被动态的申请并调用，因此cv2.so的缺失，与OpenCV源码在对支持python的接口部分编译出现了问题，或者是OpenCV编译时并没有编译python接口模块。 ​ 前面在2.2与2.3中提到，在该bug场景当中，整个编译流程并没有interrupt，因此编译报错的情况首先应可以排除，那么cv2.so无法生成的原因就可以限定于是OpenCV没有编译python接口模块。 ​ 那么，为什么OpenCV没有编译python接口呢？ ​ 2.3中提到，OpenCV在一些not found warning中，会对模块的编译产生受限，那么python接口的未编译就极有可能是因为OpenCV在cmake阶段查询python环境时，未查询到python的某部分环境，在编译阶段无法链接所需python库，最终导致了python接口的未编译。 ​ 最终在cmake的log文件当中： 1-- Could NOT find PythonLibs (missing: PYTHON_INCLUDE_DIRS) 验证了当前猜想。 ​ 因此，我们可以归结出OpenCV编译无法生成cv2.so在该场景下的成因，即是当前环境下python库的缺失。 补充​ 3.1中已对bug成因进行了分析，在这里补充一下为什么在已有python环境的情况下，依然会有类库依赖缺失问题。 ​ Linux发行版通常会把类库的头文件和相关的pkg-config分拆成一个单独的xxx-dev(el)包。针对python环境下，该类库即python-dev。 ​ 那么什么情况需要安装python-dev？ ​ 1. 需要自己安装一个源外的python类库, 而这个类库内含需要编译的调用python API的c/c++文件（如：安装使用WiringpisPi库需要python-dev）。 ​ 2. 你自己写的一个程序编译需要链接libpythonXX.(a/so)(注:以上不含使用ctypes/ffi或者裸dlsym方式直接调用libpython.so) ​ 其他正常使用python或者通过安装源内的python类库的不需要python-dev. 发现并修复bug过程​ 4中归纳1-3中发现并修复bug的过程： ​ 1. 查看cv2.so链接状态，并发现cv2.so缺失。 ​ 2. 进行重编译，确认流程步骤完整，并尝试bug复现。 ​ 3. 查看cmake过程的log文件，未发现实际相关error。查看lib文件夹下libopencv类库链接正常。 ​ 4. 确认是否为cmake参数问题，核对参数，并对相关参数条件覆盖测试(各取OFF/ON)。依然无法修复bug，排除cmake参数问题。 ​ 5. 尝试使用OpenCV3.4.6（原3.4.0）进行编译，仍然无法修复bug，排除版本更替丢失或兼容性问题。 ​ 6. 查询到一个案例（见参考资料），该案例因在python中没有安装numpy库依赖，导致最终cv2.so无法生成。该案例提供了本bug场景的一个解决思路，即cv2.so的生成失败可能与python环境缺失相关。 ​ 7. 查看log文件，发现python类库在编译过程中并未找到，支持了步骤6中的猜想。 ​ 8. “sudo apt-get install python2.7-dev”安装python类依赖。 ​ 9. 重新编译，成功生成cv2.so，并可通过“import”测试。 参考资料百度百科(opencv): https://baike.baidu.com/item/opencv/10320623?fr=aladdin pyimagesearch(Install OpenCV 3.0 and Python 2.7+ on Ubuntu): https://www.pyimagesearch.com/2015/06/22/install-opencv-3-0-and-python-2-7-on-ubuntu/ cnblogs(没有cv2.so文件): https://www.cnblogs.com/whu-zeng/p/6284795.html cnblogs(python和python-dev): https://www.cnblogs.com/cj2014/p/3848673.html csdn(Linux下动态库和静态库的制作及使用): https://blog.csdn.net/AXW2013/article/details/86495942]]></content>
      <categories>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>Environment</tag>
        <tag>OpenCV</tag>
        <tag>CV</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PCLNote]]></title>
    <url>%2F2019%2F11%2F14%2FPCLNote%2F</url>
    <content type="text"><![CDATA[PCL（Point Cloud Library， 点云库）是一个大型跨平台开源C++编程库，实现了大量点云相关的通用算法和高效数据结构。 PCL是BSD授权方式，可以免费进行商业和学术的应用。 包含模块 分割 (Segmentation) 特征描述与提取 (Features) 可视化 (Visualization) 曲面重建 (Surface) 识别 (Recognition) 检索 (Search) 配准 (Registration) 关键点 (Keypoints) 滤波 (Filters) 采样一致性 (Sample consensus) 八叉树 (octree) 通用模块 (common) 输入输出 (IO) k维树 (kdtree) 适用平台 普通多核或单核计算机（x86…） 嵌入式专用系统（ARM …） RGBD及其他点云获取设备 GPU kdtree, octree三维测量设备获取的点云数据，具有数据量大、分布不均匀等特点。作为三维领域里面另一个重要的数据来源，点云数据主要是表征目标表面的海量点集合，并不具备传统实体网格数据的几何拓扑信息。点云数据处理中最为核心的问题就是建立离散点间的拓扑关系，实现基于领域关系的快速查找。 建立空间索引在点云数据处理中被广泛应用，而这些结构中，k-d tree和八叉树在3D点云数据组织中的应用较为广泛。PCL对八叉树的数据结构建立和索引方法进行了实现，以方便在此基础上的其他点云处理操作。 Filters在获取点云数据时，由于环境等因素带来的影响，以及电磁波衍射特性、被测物体表面性质变化和数据拼接配准操作过程的影响，点云数据将不可避免地出现一些噪声点。 实际应用中，除了测量随机误差产生的噪声点之外，由于受到外界干扰如视线遮挡、障碍物等因素的影响，点云数据中往往存在着一些离主体点云（即被测物体点云）较远的离散点，即离群点，不同的获取设备点云噪声结构也有不同，其它可以通过滤波重采样完成的工作，有空洞修复、信息损失最小海量点云数据压缩处理等。 在点云处理流程中，滤波处理作为预处理的第一步，往往对后续处理管道影响很大，只有在滤波预处理中将噪声点、离群点、孔洞、数据压缩等按照后续处理定制，才能够更好地进行配准等后续应用处理。 PCL中点云滤波模块提供了很多灵活实用的滤波处理算法，例如双边滤波、高斯滤波、条件滤波、直通滤波、基于随机采样一致性滤波等，关键的滤波模块是作为PCL的一个处理成员模块，其在应用中与其它点云处理流程集成。 Keypoints关键点也称为兴趣点，它是2D图像、3D点云或曲面模型上，可以通过定义检测标注来获取的具有稳定性、区别性的点集。 从技术上来说，关键点的数量相比与原始点云或图像的数据量小很多，它与局部特征描述子结合在一起，组成关键点描述子，常用来形成原始数据的紧凑表示，而且不失代表性与描述性，从而可以加快后续识别、追踪等对数据的处理速度。关键点提取是2D与3D信息处理中不可或缺的关键技术。 Sample consensus在CV领域广泛应用各种不同的采样一致性参数估计算法，用于排除错误的样本，样本不同，对应的应用则不同，例如剔除错误的配准点对，分割出处在模型上的点集等。 PCL中以随机采样一致性算法（RANSAC）为核心，同时实现了五种类似于随机采样一致性估计（RANSAC）、最大似然一致性估计（MLESAC）、最大中值方差一致性估计（LMEDS）等，所有的估计参数算法都符合一致性准则。 Features3D点云特征描述与提取是点云信息处理中最基础也是最关键的一部分，点云的识别、分割、重采样、配准、曲面重建等处理的大部分算法，都严重依赖特征描述与提取的结果。 从尺度上来分，一般分为局部特征描述和全局特征描述，例如局部的法线等几何形状特征的描述，全局的拓扑特征描述，都属于3D点云特征描述与提取范畴。 在PCL中，目前已有很多基本的特征描述子与提取算法。 Registration在逆向工程、CV、文物数字化等领域中，由于点云的不完整、旋转错位、平移错位等，使得要得到完整点云就需对局部点云就需对点云进行配准。 为了得到被测物体的完整数据模型，需要确定一个合适的坐标变换，将从各个视角得到的点集合并到一个统一的坐标系下，形成一个完整的数据点云，然后就可以方便地进行可视化等操作，这就是点云数据的配准。 点云自动配准有手动配准、依赖仪器的配准和自动配准。通常我们所说的点云配准技术即是指自动配准。 点云自动配准技术是通过一定的算法或者统计学规律，利用计算机计算两块点云之间的错位，从而达到把两片点云配准的效果。其实质是把在不同的坐标系中测量得到的数据点云进行坐标变换，以得到整体的数据模型。问题的关键是如何求得坐标变换参数R（旋转矩阵）和T（变换向量），使得两视角下测得的三维数据经坐标转换后的距离最小。 目前，配准算法按照实现过程可以分为整体配准和局部配准。 PCL中有单独的配准模块，实现了相关的基础数据结构与经典配准算法如ICP等，以及配准过程中的对应点估计、错误对应点去除等流程。配准的关键技术设计关键点选取、与特征描述与提取两部分。 Surface曲面重建技术在逆向工程、数据可视化、机器视觉、虚拟现实、医疗技术等领域中得到了广泛的应用。 根据重建曲面和数据点云之间的关系可将曲面重建分为两大类：插值法和逼近法。前者得到的重建曲面完全通过原始数据点，而后者则是用分片线性曲面或其它形式的曲面来逼近原始数据点，从而使得产生的重建曲面是原始点集的一个逼近。而根据重建曲面的表现形式不同又可以将它分为以下五种：参数曲面重建、隐式曲面重建、变形曲面重建、细分曲面重建和分片线性曲面重建。 PCL中目前实现了基于点云的曲面重建模块框架，在此基础上进一步实现了比较基础的泊松重建、MC重建、Ear Clipping等算法。 Reference《点云库PCL从入门到精通》]]></content>
      <categories>
        <category>LIDAR</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>LIDAR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[libLAS编译安装]]></title>
    <url>%2F2019%2F11%2F07%2FLibLAS%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[libLAS是一个C/C++库，用于读取和写入常见的LAS LIDAR格式。 编译GeoTIFF12345wget https://download.osgeo.org/geotiff/libgeotiff/libgeotiff-1.3.0.tar.gztar -xvf libgeotiff-1.3.0.tar.gz &amp;&amp; cd libgeotiff-1.3.0./configuremakesudo make install 编译libLAS1234mkdir makefiles &amp;&amp; cd makefilescmake -G "Unix Makefiles" ..makemake install 验证1lasinfo &lt;file_path&gt; PDAL截至2018年，libLAS已经被PDAL项目取代，进入休眠和维护状态。libLAS不提供PDAL提供的对LAS或LAZ 1.4的支持。 并且PDAL提供Python的支持。]]></content>
      <categories>
        <category>LIDAR</category>
      </categories>
      <tags>
        <tag>LIDAR</tag>
        <tag>Environment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[本地hexo博客迁移]]></title>
    <url>%2F2019%2F11%2F07%2F%E6%9C%AC%E5%9C%B0hexo%E5%BA%93%E8%BF%81%E7%A7%BB%2F</url>
    <content type="text"><![CDATA[Hexo博客本地库迁移至另一台主机参考流程。 Hexo搭建可参考：https://rfishrock.github.io/2016/10/03/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/ 复制原本地文件将下面的文件或文件夹复制到新的博客目录下进行替换： 123_config.ymlsource/themes/ Hexo各文件说明.deploy：执行hexo deploy命令部署到GitHub上的内容目录 public：执行hexo generate命令，输出的静态网页内容目录 scaffolds：layout模板文件目录，其中的md文件可以添加编辑 scripts：扩展脚本目录，这里可以自定义一些javascript脚本 source：文章源码目录，该目录下的markdown和html文件均会被hexo处理。该页面对应repo的根目录，404文件、favicon.ico文件，CNAME文件等都应该放这里，该目录下可新建页面目录。 _drafts：草稿文章 _posts：发布文章 themes：主题文件目录 _config.yml：全局配置文件，大多数的设置都在这里 package.json：应用程序数据，指明hexo的版本等信息，类似于一般软件中的关于按钮 Referencehttps://www.jianshu.com/p/a713bd430e0f]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开源许可证Note]]></title>
    <url>%2F2019%2F11%2F05%2F%E5%BC%80%E6%BA%90%E8%AE%B8%E5%8F%AF%E8%AF%81Note%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>OpenSource</category>
      </categories>
      <tags>
        <tag>OpenSource</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LivoxNote]]></title>
    <url>%2F2019%2F11%2F05%2FLivoxNote%2F</url>
    <content type="text"><![CDATA[产品概述 坐标系]]></content>
      <categories>
        <category>LIDAR</category>
      </categories>
      <tags>
        <tag>LIDAR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TensorFlow各版本对应]]></title>
    <url>%2F2019%2F10%2F30%2FTensorFlow%E5%90%84%E7%89%88%E6%9C%AC%E5%AF%B9%E5%BA%94%2F</url>
    <content type="text"><![CDATA[TensorFlow对应各环境下的版本，即不同版本下所需环境。 Windowshttps://tensorflow.google.cn/install/source_windows CPU GPU Linuxhttps://tensorflow.google.cn/install/source CPU GPU macOSCPU GPU]]></content>
      <categories>
        <category>DeepLearning</category>
      </categories>
      <tags>
        <tag>TensorFlow</tag>
        <tag>DeepLearning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法复杂度Note]]></title>
    <url>%2F2019%2F10%2F30%2F%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[在大O符号表示法中，时间复杂度的公式是： T(n) = O( f(n) )，其中f(n) 表示每行代码执行次数之和，而 O 表示正比例关系，这个公式的全称是：算法的渐进时间复杂度。 常见的时间复杂度量级从上至下依次的时间复杂度越来越大，执行的效率越来越低。 常数阶O(1) 对数阶O(logN) 线性阶O(n) 线性对数阶O(nlogN) 平方阶O(n^2) 立方阶O(n^3) K次方阶O(n^k) 指数阶(2^n) 常数阶O(1)无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)，如： 12345int i = 1;int j = 2;++i;j++;int m = i + j; 上述代码在执行的时候，它消耗的时候并不随着某个变量的增长而增长，那么无论这类代码有多长，即使有几万几十万行，都可以用O(1)来表示它的时间复杂度。 对数阶O(logN)12345int i = 1;while(i &lt; n)&#123; i = i * 2;&#125; 从上面代码可以看到，在while循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了。我们试着求解一下，假设循环x次之后，i 就大于 n 了，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 x = log2n。 也就是说当循环log2n次以后，这个代码就结束了。因此这个代码的时间复杂度为：O(logn)。 线性阶O(n)12345for(i=1; i&lt;=n; ++i)&#123; j = i; j++;&#125; 这段代码，for循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的，因此这类代码都可以用O(n)来表示它的时间复杂度。 线性对数阶O(nlogN)线性对数阶O(nlogN) 其实非常容易理解，将时间复杂度为O(logn)的代码循环N遍的话，那么它的时间复杂度就是 n * O(logN)，也就是了O(nlogN)。 12345678for(m=1; m&lt;n; m++)&#123; i = 1; while(i &lt; n) &#123; i = i * 2; &#125;&#125; 平方阶O(n^2)如果把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²) 了。 12345678for(x=1; i&lt;=n; x++)&#123; for(i=1; i&lt;=n; i++) &#123; j = i; j++; &#125;&#125; 这段代码其实就是嵌套了2层n循环，它的时间复杂度就是 O(n*n)，即 O(n²)如果将其中一层循环的n改成m，即： 12345678for(x=1; i&lt;=m; x++)&#123; for(i=1; i&lt;=n; i++) &#123; j = i; j++; &#125;&#125; 那它的时间复杂度就变成了 O(m*n) 立方阶O(n^3)、K次方阶O(n^k)参考上面的O(n^2) 去理解就好了，O(n^3)相当于三层n循环，其它的类似。 Referencehttps://blog.csdn.net/jsjwk/article/details/84315770]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python在字符串前补零]]></title>
    <url>%2F2019%2F10%2F11%2FPython%E5%9C%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%89%8D%E8%A1%A5%E9%9B%B6%2F</url>
    <content type="text"><![CDATA[用于对不规则字符串（如命名）进行转换。 zfill() &amp; rjust()Python zfill() 方法返回指定长度的字符串，原字符串右对齐，前面填充0。 1str.zfill(width) Python rjust() 返回一个原字符串右对齐,并使用空格填充至长度 width 的新字符串。如果指定的长度小于字符串的长度则返回原字符串。 width – 指定填充指定字符后中字符串的总长度. fillchar – 填充的字符，默认为空格。 1str.rjust(width[, fillchar]) 示例： 1234img_name = "1011"print(img_name.zfill(6))print(img_name.rjust(6, '0')) 输出： 12001011001011 补充补充特殊情况。 1234img_name = "1011"print(img_name.zfill(1))print(img_name.rjust(1, '0')) 输出： 1210111011 rjust()可使用单个字符对字符串进行补足。另外有rjust()， Python也提供有ljust()。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu中NVIDIA驱动安装]]></title>
    <url>%2F2019%2F10%2F08%2FUbuntu%E4%B8%ADNVIDIA%E9%A9%B1%E5%8A%A8%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Ubuntu系统中本身不带有英伟达显卡驱动，然而如果需要安装CUDA、CUDNN则必须有驱动支持。 获取显卡支持驱动的版本https://www.nvidia.com/Download/index.aspx 提供该显卡目前版本驱动 https://www.geforce.cn/drivers 提供该显卡支持的所有驱动 通过以上两个网址可以获得显卡支持的驱动版本信息以及驱动下载。相对来说比较推荐采用第二个网址取获得多个版本的驱动，因为新版驱动相对支持的CUDA以及模型较少。 关于是否需要禁用Nouveau这里先提前讨论一下关于网上教程一般会提到的禁用Nouveau问题。Nouveau是第三方的开源NVIDIA驱动。然而目前也有教程上提过一些方法安装驱动不需要禁用Nouveau与图形界面。之前的配置经验中确实也有过在不禁用情况下，成功安装了驱动。因此，是否禁用Nouveau，是否会因此造成什么样的问题，目前还不好定论。 安装驱动这里介绍三种安装Nvidia驱动的方法，可以根据自己的需要进行安装。 使用标准Ubuntu库安装驱动 检测显卡型号以及推荐的驱动： 1ubuntu-drivers devices 从此命令中可以获得显卡所支持的驱动版本，包括系统推荐的驱动版本。 如果选择安装推荐的驱动版本，则也直接使用命令： 1sudo ubuntu-drivers autoinstall 如果想自己选择安装的版本，则可以使用： 1sudo apt install nvidia-version 重启系统。 使用PPA库安装驱动PPA为Personal Package Archives的缩写，即个人软件包档案。 Personal Package Archives（个人软件包档案）是Ubuntu Launchpad网站提供的一项服务，允许个人用户上传软件源代码，通过Launchpad进行编译并发布为2进制软件包，作为apt/新立得源供其他用户下载和更新。在Launchpad网站上的每一个用户和团队都可以拥有一个或多个PPA。 使用PPA库可安装不稳定版本的Beta驱动。 添加PPA库至系统中： 12sudo add-apt-repository ppa:graphics-drivers/ppasudo apt update 后续步骤可参考3.1中步骤1-3。 手动安装NVIDIA官方网站中驱动 识别NVIDIA VGA卡： 1lshw -numeric -C display 或者： 1lspci -vnn | grep VGA 从官方网站中下载驱动。 禁用默认的Nouveau驱动。 将Nouveau驱动加入黑名单。 12sudo bash -c "echo blacklist nouveau &gt; /etc/modprobe.d/blacklist-nvidia-nouveau.conf"sudo bash -c "echo options nouveau modeset=0 &gt;&gt; /etc/modprobe.d/blacklist-nvidia-nouveau.conf" 验证新modprobe config文件内容： 1cat /etc/modprobe.d/blacklist-nvidia-nouveau.conf 应显示： 12blacklist nouveauoptions nouveau modeset=0 更新Kernel initramfs： 1sudo update-initramfs -u 重启系统： 1sudo reboot 验证Nouveau是否已经禁用： 1lsmod | grep nouveau 无显示则已经禁用。 此步骤之前确保系统已经重启并禁用Nouveau。暂停图形界面： 1sudo telinit 3 按CTRL+ALT+F1进入TTY1会话，并使用用户名与密码登录。 启用驱动安装： 1bash NVIDIA-Linux-x86_64-version.bin 重启系统。 验证驱动是否安装安装完成后，可通过NVIDIA X Server Settings验证驱动版本。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu中typora安装]]></title>
    <url>%2F2019%2F10%2F07%2FUbuntu%E4%B8%ADtypora%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Markdown编辑器与阅读器。 安装1234wget -qO - https://typora.io/linux/public-key.asc | sudo apt-key add -sudo add-apt-repository 'deb https://typora.io/linux ./'sudo apt-get updatesudo apt-get install typora MarkdownMarkdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。 当前许多网站都广泛使用 Markdown 来撰写帮助文档或是用于论坛上发表消息。例如：GitHub、简书、reddit、Diaspora、Stack Exchange、OpenStreetMap 、SourceForge等。 菜鸟教程 https://www.runoob.com/markdown/md-tutorial.html]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu中sublime text安装]]></title>
    <url>%2F2019%2F10%2F07%2FUbuntu%E4%B8%ADsublime-text%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[用于日常代码编写，以及文本查看。 安装（Stable）12345wget -qO - https://download.sublimetext.com/sublimehq-pub.gpg | sudo apt-key add -sudo apt-get install apt-transport-httpsecho "deb https://download.sublimetext.com/ apt/stable/" | sudo tee /etc/apt/sources.list.d/sublime-text.listsudo apt-get updatesudo apt-get install sublime-text 显示编辑器中空格显示空格在于方便检查python等语法的严格缩进。同样适用于Windows下。 菜单中选择Preferences，Settings。在settings-User中添加 1"draw_white_space": "all"]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu中apt源与pip源替换]]></title>
    <url>%2F2019%2F10%2F03%2FUbuntu%E4%B8%ADapt%E6%BA%90%E4%B8%8Epip%E6%BA%90%E6%9B%BF%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[Advanced Packaging Tool (apt) 是Linux下的安装包管理工具。Pip 是 Python 包管理工具,该工具提供了对Python 包的查找、下载、安装、卸载的功能。更换源的必要性在于提高各种包的下载速度。 Apt源更换为阿里镜像源进入ubuntu“软件与更新”。ubuntu软件分页中，“下载自”选项选择使用http://mirros.aliyun.com/ubuntu 阿里云镜像源。 Pip源更换为清华源修改 ~/.pip/pip.conf (没有可自行创建)，修改index-url至tuna，内容如下： 12[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple Conda源更换为清华源输入如下两行命令： 12conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --set show_channel_urls yes]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Pip</tag>
        <tag>Conda</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu系统安装]]></title>
    <url>%2F2019%2F10%2F02%2FUbuntu%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Ubuntu16.04 LTS安装记录。 通过国内镜像获得系统镜像文件访问网易开源镜像站 http://mirrors.163.com/ 获得 ubuntu-16.04.6-desktop-amd64.iso 文件。 刻录引导盘使用Rufus https://rufus.ie/en_IE.html 将ISO文件刻入至所选择U盘。刻入过程将使U盘格式化。 进入主机Bios并设置U盘启动项开机时进入Bios界面，不同型号主板Bios不同。 华硕TUF主板 开机按Del或F2进入Bios。 进入Advanced Mode。 选择Boot并进入Secure Boot。 将OS Type修改为Windows UEFI mode。 进入Key Management， 选择Clear Secure Boot Keys关闭Secure Boot。 返回初始Bios界面，通过Boot Menu选择U盘路径进行启动。 安装系统语言推荐初始选择英语，防止出现英文路径不匹配情况。 安装过程推荐选择不联网安装，减少因为网络问题安装时间的延长。 系统安装分为双系统安装与单系统安装。 先了解系统安装中系统分区中，各分区思路。 [分区：主分区] [格式：Ext4] [挂载点：/] [空间起始位置] 系统分区。 [分区：逻辑分区] [格式：] [挂载点：swap] [空间起始位置] 当使用所有RAM容量时，操作系统需要释放一些RAM，并且需要一个位置来将被选择的被释放的信息保留在RAM中，这就是所谓的交换空间。 交换空间通常是硬盘中的特殊分区，与计算机的RAM容量成正比。对于少于8GB的RAM：使用2或3倍的RAM量。对于超过8gb且小于64gb：使用1到1.5倍的RAM量。超过64gb：4gb的互换或完全没有交换。 [分区：逻辑分区] [格式：Ext4] [挂载点：/boot] [空间起始位置] 用于系统引导。 [分区：逻辑分区] [格式：Ext4] [挂载点：/home] [空间起始位置] 存储分区。 Windows与Ubuntu双系统策略双系统安装，推荐在安装好Windows系统后，再启动Ubuntu安装程序。在安装引导程序中，直接选择保留Windows安装Ubuntu选项（不考虑前面所提分区策略，使用安装程序默认分配方案）。因为两个系统所采用的文件格式不相同，在Windows系统下，无法查看到Ubuntu系统分区以及文件。而Ubuntu系统则可以与Windows共用挂载盘。因此在之后如果出现需要在Windows系统下再次调整分区时，要特别注意该特性。 之后安装程序将引导对Windows与Ubuntu两个系统的磁盘空间进行分配。注意如果安装过程中没有出现磁盘空间分配过程，应为分区出现问题。需中断当前安装，检查当前的分区情况。此过程中分配与Ubuntu的空间，为Ubuntu系统主分区。之后Ubuntu可使用Windows挂载分区作为逻辑分区。 Ubuntu单系统策略推荐自定义分区，在Ubuntu系统需要重装时，重新分配系统分区是非常有帮助的。 目前个人的分区方案： [分区：主分区] [格式：Ext4] [挂载点：/] [空间起始位置] [分配空间：0.65*(500g-32gb-200mb)] [分区：逻辑分区] [格式：] [挂载点：swap] [空间起始位置] [分配空间：32gb] [分区：逻辑分区] [格式：Ext4] [挂载点：/boot] [空间起始位置] [分配空间：200mb] [分区：逻辑分区] [格式：Ext4] [挂载点：/home] [空间起始位置] [分配空间：0.35*(500g-32gb-200mb)]]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo引入本地相对路径图片]]></title>
    <url>%2F2019%2F10%2F02%2FHexo%E5%BC%95%E5%85%A5%E6%9C%AC%E5%9C%B0%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[在Blog中将原先使用外链引入的图片改为本地引入图片。 相对路径引用将Hexo站点配置文件_config.yml中post_asset_folder属性改为true。 这时假使我们创建新post， 1hexo new post_name 我们将在_post文件夹下获得post_name.md文件以及post_name文件夹。post_name文件夹用于存储引入的图片。同时在post_name.md中引入图片： 1&#123;% asset_img img_name img_alt %&#125; 为什么不使用![]方法Hexo本身使用![]方法插入图片是没有问题的， 1![img_alt](img_name) 在post下也可正常显示。然而在next主题中，如加入read more功能时，主页中图片的路径会因为使用相对路径而无法正常显示。因此此时选择使用hexo3新方法：{}。]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[仿淘宝登录网页编写]]></title>
    <url>%2F2016%2F10%2F16%2F%E7%99%BB%E5%BD%95%E7%BD%91%E9%A1%B5%E7%BC%96%E5%86%99%2F</url>
    <content type="text"><![CDATA[HTML+CSS+javascript Set Up WebStorm DetailWebStorm一款JavaScript 开发工具。被广大中国JS开发者誉为“Web前端开发神器”、“最强大的HTML5编辑器”、“最智能的JavaScript IDE”等。与IntelliJ IDEA同源，继承了IntelliJ IDEA强大的JS部分的功能。 HTML一种超文本标记语言，标准通用标记语言下的一个应用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;link href="bootstrap-3.3.5-dist/css/bootstrap.min.css " rel="stylesheet"&gt; &lt;link href="styles.css" rel="stylesheet"&gt; &lt;link href="js.js" rel="stylesheet"&gt; &lt;script language="JavaScript" src="js.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="top"&gt; &lt;img src="logo.png"&gt;&lt;/div&gt;&lt;div class="mid"&gt; &lt;div class="midin"&gt; &lt;form class="login"&gt; &lt;div class="title"&gt;&lt;b style="display: block;" id="login_txt"&gt;用户登录&lt;/b&gt; &lt;div class="alert alert-danger" id="alert_warn" &gt; &lt;img src="error.png" alt="warn"&gt; &lt;b id="warn_txt"&gt;&lt;/b&gt; &lt;/div&gt; &lt;div class="alert alert-success" id="alert_success"&gt; &lt;b&gt;&amp;nbsp;登录成功&lt;/b&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="input-group"&gt; &lt;span class="input-group-addon" &gt; &lt;span class="glyphicon glyphicon-user"&gt; &lt;/span&gt; &lt;/span&gt; &lt;input type="text" class="form-control" value=" 账号（手机号）" id="username" onFocus="if(value==defaultValue)&#123;value='';this.style.color='#000'&#125;" onBlur="if(!value)&#123;value=defaultValue;this.style.color='#c2a599';&#125;" style="color:#999999; font-family: 'Microsoft YaHei UI'; width: 260px" maxlength="11" onkeyup="this.value=this.value.replace(/\D/g,'')" onafterpaste="this.value=this.value.replace(/\D/g,'')"&gt; &lt;/div&gt; &lt;div class="input-group"&gt; &lt;span class="input-group-addon"&gt; &lt;span class="glyphicon glyphicon-lock"&gt; &lt;/span&gt; &lt;/span&gt; &lt;input type="text" class="form-control" value=" 密码" name="input_psw" oninput="pswInputting()" id="password" onFocus="if(value==defaultValue)&#123;value='';this.style.color='#000'&#125;" onBlur="if(!value)&#123;value=defaultValue;this.style.color='#c2a599';&#125;" style="color:#999999; font-family: 'Microsoft YaHei UI'; width: 260px" maxlength="32"&gt; &lt;/div&gt; &lt;button class="btn" type="button" onclick="setTimeout($tip(), 200);" id="btn_submit"&gt;登 录&lt;/button&gt; &lt;a href="#" id="forget"&gt;忘记密码&lt;/a&gt; &lt;a href="#" id="reg"&gt;免费注册&lt;/a&gt; &lt;/form&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class="bottom"&gt; &lt;hr&gt; &lt;div class="b1"&gt; &lt;a href="#"&gt;阿里巴巴集团&lt;/a&gt; | &lt;a href="#"&gt;阿里巴巴国际站&lt;/a&gt; | &lt;a href="#"&gt;阿里巴巴中国站&lt;/a&gt; | &lt;a href="#"&gt;全球速卖通&lt;/a&gt; | &lt;a href="#"&gt;淘宝网&lt;/a&gt; | &lt;a href="#"&gt;天猫&lt;/a&gt; | &lt;a href="#"&gt;聚划算&lt;/a&gt; | &lt;a href="#"&gt;一陶&lt;/a&gt; | &lt;a href="#"&gt;阿里妈妈&lt;/a&gt; | &lt;a href="#"&gt;淘宝旅行&lt;/a&gt; | &lt;a href="#"&gt;虾米&lt;/a&gt; | &lt;a href="#"&gt;阿里云计算&lt;/a&gt; | &lt;a href="#"&gt;云OS&lt;/a&gt; | &lt;a href="#"&gt;万网&lt;/a&gt; | &lt;a href="#"&gt;支付宝&lt;/a&gt; | &lt;a href="#"&gt;来往&lt;/a&gt; | &lt;hr&gt; &lt;/div&gt; &lt;div class="b2"&gt; &lt;div class="b21"&gt; &lt;a href="#"&gt;关于淘宝&lt;/a&gt; &lt;a href="#"&gt;合作伙伴&lt;/a&gt; &lt;a href="#"&gt;营销中心&lt;/a&gt; &lt;a href="#"&gt;廉政举报&lt;/a&gt; &lt;a href="#"&gt;联系客服&lt;/a&gt; &lt;a href="#"&gt;开放平台&lt;/a&gt; &lt;a href="#"&gt;诚征英才&lt;/a&gt; &lt;a href="#"&gt;联系我们&lt;/a&gt; &lt;a href="#"&gt;网站地图&lt;/a&gt; &lt;a href="#"&gt;法律声明&lt;/a&gt; @2016 Taobao.com 版权所有 &lt;/div&gt; 网络文化经营许可证； 网文网[2010]040号 | &lt;span id="zengzhi"&gt;增值电信业务经营许可证：浙B2-20080224-1 | 信息网络传播许可证：1109364&lt;/span&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; CSS一种用来表现HTML（标准通用标记语言的一个应用）或XML（标准通用标记语言的一个子集）等文件样式的计算机语言。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111.body&#123; margin: 0; padding: 0;&#125;.top&#123; width: 1200px; height: 80px; margin:0 auto 0 auto; padding:15px 0 15px 0;&#125;.mid&#123; height: 600px; background: url("login-bg.jpg") no-repeat center;&#125;.blank&#123; height: 70px;&#125;.bottom&#123; width: 1200px; margin: 0 auto 0 auto;&#125;.b1&#123; height: 44px;&#125;.b1 a&#123; color: #666;&#125;.b2&#123; height: 60px;&#125;.b21&#123; height: 30px;&#125;.b21 a&#123; color:#555555&#125;#zengzhi&#123; color: #333;&#125;.login&#123; float: right; width: 350px; height: 350px; background-color: #f1f6ff; margin-top: 100px; border-radius: 5px;&#125;.midin&#123; width: 1200px; margin: 0 auto 0 auto;&#125;.title&#123; margin: 35px 20px 35px 20px;&#125;.input-group&#123; margin: 0 20px 30px 20px; height: 40px;&#125;.input-group input&#123; height: 40px;&#125;.btn&#123; width: 310px; background-color: #f84e4e; margin:0 20px 30px 20px; font-family:"黑体"; color:white;&#125;.btn:hover&#123; background-color: #f89999; color:white;&#125;#forget&#123; float: left; margin-left: 20px; color:#555555;&#125;#reg&#123; float: right; margin-right: 20px; color:#555555;&#125;#alert_warn&#123; display: none; hegiht: 27px; margin-right: 11px; padding: 0px;&#125;#alert_warn img&#123; width: 22px; hegiht: 22px; color:white;&#125;#alert_warn b&#123; color: #ff2624; font-size: smaller; font-weight: 700; font-size: 15px;&#125;#alert_success&#123; display: none; height: 27px; margin-right: 11px; padding: 0px;&#125;#alert_success b&#123; color: #1d8031; font-size: smaller; font-weight: 700; font-size: 15px;&#125; javascript一种直译式脚本语言，是一种动态类型、弱类型、基于原型的语言，内置支持类型。它的解释器被称为JavaScript引擎，为浏览器的一部分，广泛用于客户端的脚本语言，最早是在HTML（标准通用标记语言下的一个应用）网页上使用，用来给HTML网页增加动态功能。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980function pswInputting() &#123; var psw_input = document.getElementsByName("input_psw").item(0); var str = psw_input.value; if (str.length != 0) &#123; if (str == " 密码") &#123; return; &#125; psw_input.type = "password"; &#125; else &#123; psw_input.type = "text"; &#125;&#125;function $tip()&#123; var username = document.getElementById("username"); var password = document.getElementsByName("input_psw").item(0); var reg = /^0?1[3|4|5|8][0-9]\d&#123;8&#125;$/; var login_txt = document.getElementById("login_txt"); var warn_txt = document.getElementById("warn_txt"); var block = document.getElementById("alert_warn"); var block_success = document.getElementById("alert_success"); var btn = document.getElementById("btn_submit"); btn.style.color = "#ffffff"; btn.blur(); var flag; setTimeout("", 200); if (username.value == " 账号（手机号）" || username.value == "") &#123; warn_txt.innerHTML = "&lt;strong&gt;账户不能为空！&lt;/strong&gt;"; flag = 1; &#125; else if (!reg.test(username.value)) &#123; warn_txt.innerHTML = "&lt;strong&gt;账户为11位有效手机号！&lt;/strong&gt;"; flag = 2; &#125;else if (password.value == " 密码" || password.value == "") &#123; warn_txt.innerHTML = "&lt;strong&gt;密码不能为空！&lt;/strong&gt;"; flag = 4; &#125; else if (username.value != "13012345678") &#123; warn_txt.innerHTML = "&lt;strong&gt;用户尚未注册！&lt;/strong&gt;"; flag = 3; &#125; else if (password.value != "123456") &#123; warn_txt.innerHTML = "&lt;strong&gt;密码错误！&lt;/strong&gt;"; flag = 5; &#125; else &#123; block.style.display = "none"; block_success.style.display = "block"; login_txt.style.display = "none"; flag = 6; &#125; setTimeout("reset()", 3000); switch (flag) &#123; case 1: case 2: case 3: block_success.style.display = "none"; login_txt.style.display = "none"; block.style.display = "block"; var elem = document.getElementById("username"); elem.focus(); break; case 4: case 5: block_success.style.display = "none"; login_txt.style.display = "none"; block.style.display = "block"; var elem = document.getElementById("password"); elem.focus(); break; case 6: break; &#125;&#125;function reset() &#123; var login_txt = document.getElementById("login_txt"); var block = document.getElementById("alert_warn"); var block_success = document.getElementById("alert_success"); login_txt.style.display = "block"; block.style.display = "none"; block_success.style.display = "none";&#125; Problems and SolutionsCSS盒子模型网页设计中常听的属性名：内容(content)、填充(padding)、边框(border)、边界(margin)， CSS盒子模式都具备这些属性。这些属性我们可以用日常生活中的常见事物——盒子作一个比喻来理解，所以叫它盒子模式。CSS盒子模型就是在网页设计中经常用到的CSS技术所使用的一种思维模型。 内容（CONTENT）就是盒子里装的东西；而填充(PADDING)就是怕盒子里装的东西（贵重的）损坏而添加的泡沫或者其它抗震的辅料；边框(BORDER)就是盒子本身了；至于边界(MARGIN)则说明盒子摆放的时候的不能全部堆在一起，要留一定空隙保持通风，同时也为了方便取出。在网页设计上，内容常指文字、图片等元素，但是也可以是小盒子（DIV嵌套），与现实生活中盒子不同的是，现实生活中的东西一般不能大于盒子，否则盒子会被撑坏的，而CSS盒子具有弹性，里面的东西大过盒子本身最多把它撑大，但它不会损坏的。填充只有宽度属性，可以理解为生活中盒子每个HTML标记都可看作一个盒子；]]></content>
      <categories>
        <category>Front-end</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>CSS</tag>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[静态博客搭建]]></title>
    <url>%2F2016%2F10%2F03%2F%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[Github+Git+Hexo+NexT+Markdown Set Up Node.js Git DetailGithub一个面向开源及私有软件项目的托管平台,只支持Git。在Github上注册用户，并新建repository(username.github.io)。 Git一款免费、开源的分布式版本控制系统。在站点目录（本地blog文件夹)右键Git Bash here。 123$ git init //初始一个Git仓库$ git config --global user.name 'yourname' //首次需设置账户$ git config --global user.email 'youremail' //首次设置账户邮箱 配置SSH Keys。 12$ ssh-keygen -t rsa -C youremail@example.com //生成SSH Key$ cd~/.ssh //检查本机的ssh密钥 将公钥文件中内容复制到Github账号的SSH Key中。 1$ ssh git@github.com //检查是否连接 后面操作大部分在Git上执行。 Hexo一个简单、快速、强大的博客发布工具，支持Markdown格式。 123$ npm install -g hexo //安装Hexo$ hexo init //在本地初始搭建一个Hexo博客$ hexo server //在本地(localhost:4000)查看博客 修改站点(blog文件夹）配置文件(_config.yml)。 1234deploy: type: git repository: git@github.com:username/username.github.io.git branch: master 继续Hexo部署。 1234$ npm install hexo-deployer-git --save //安装hexo-deployer-git$ hexo clean //清除缓存$ hexo g //生成静态网页$ hexo d //部署到远程Github 静态博客基本搭成。 NexT精于心，简于形。一个好看的Hexo博客主题，iissnan/hexo-theme-next 12$ cd your-hexo-site //进入你的站点目录$ git clone https//github.com/iissnan/hexo-theme-next themes/next//从Git上克隆主题（适用所有从从Git上克隆库的方法） 修改站点配置文件。 1theme: next 关于NexT主题配置等可以查看NexT使用文档。 Markdown一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。Hexo新建文章：在your-hexo-site/source/_posts目录下新建.md文件。 Problems and Solutions安装Hexo问题注意Node.js与Hexo版本是否相符。 win10系统版本问题因win10版本以及Hexo版本问题，在执行命令与站点配置文件修改上面都有些许不同，应根据自己的情况加以调整（此篇blog皆为本机的处理情况）。 404问题最需要注意的是自己账号（username）是否与repository的username.github.io相符。 远程博客与本地查看不相符，出现乱码问题根据分析此问题应该出在Github远程网页更新上，如果本地查看博客网页没有出现错误，就需要等待时间刷新网页之后恢复正常。 Markdown语法问题要注意所有的标记符号后一定要空格。 Addition克隆远程仓库和提交申请 1$ git clone git@github.com:username/hellogit.git 1234$ git add yourfile$ git commit -m "yourcommit"$ git remote add origin git@github.com:username/hellogit.git$ git push -u origin master]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>Git</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
